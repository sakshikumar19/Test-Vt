DETAILED QUERY LOG - 2025-03-16 20:23:52
======================================================================

QUESTION: How does Vitess handle backup and restore operations, and what are the key considerations for ensuring data integrity during these processes?

ANSWER: ### Backup and Restore Operations in Vitess
Vitess handles backup and restore operations through its support for pluggable interfaces for both **Backup Storage Services** and **Backup Engines**.

#### Backup Storage Services
Vitess currently has plugins for the following backup storage services:
* File (using a path on shared storage, e.g., an NFS mount)
* Google Cloud Storage
* Amazon S3
* Ceph

#### Backup Engines
The engine is the technology used for generating the backup. Vitess currently has plugins for:
* **Builtin**: Shutdown an instance and copy all the database files (default)
* **XtraBackup**: An online backup using Percona's XtraBackup
* **MySQL Shell**: A logical backup engine using the upstream mysqlsh dump/load tool (EXPERIMENTAL)

#### Backup Types
Vitess supports **full backups** and **incremental backups**, as well as their respective counterparts **full restores** and **point-in-time restores**.
* A **full backup** contains the entire data in the database, representing a consistent state of the data at some point in time.
* An **incremental backup** contains a changelog, or a transition of data from one state to another, implemented by making a copy of MySQL binary logs.

### Key Considerations for Ensuring Data Integrity
To ensure data integrity during backup and restore operations, consider the following:
* **Interleave full and incremental backups**: Take full backups at regular intervals (e.g., daily) and incremental backups more frequently (e.g., hourly).
* **Choose the right backup engine**: Select a backup engine that suits your workload and performance requirements.
* **Monitor backup and restore operations**: Regularly monitor backup and restore operations to ensure they complete successfully and within the expected timeframe.
* **Test restore operations**: Periodically test restore operations to ensure that backups are valid and can be successfully restored.
* **Consider storage and network constraints**: Take into account storage and network constraints when planning backup and restore operations to avoid performance impacts on the database.

By following these considerations and using Vitess's backup and restore features, you can ensure data integrity and minimize the risk of data loss during backup and restore operations.

METRICS:
  - Documents Retrieved: 4
  - Top Document Score: 0.9790027737617493
  - Response Time: 16488.86 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9790027737617493
  Content:
----------------------------------------
_backups_ for data integrity, Vitess will also create and restore backups for provisioning new tablets in an existing shard. ## Concepts Vitess supports pluggable interfaces for both [Backup Storage Services](https://github.com/vitessio/vitess/blob/main/go/vt/mysqlctl/backupstorage/interface.go) and [Backup Engines](https://github.com/vitessio/vitess/blob/main/go/vt/mysqlctl/backupengine.go). ### Backup Storage Services Currently, Vitess has plugins for: * File (using a path on shared storage, e.g. an NFS mount) * Google Cloud Storage * Amazon S3 * Ceph ### Backup Engines The engine is the techology used for generating the backup. Currently Vitess has plugins for: * Builtin: Shutdown an instance and copy all the database files (default) * XtraBackup: An online backup using Percona's [XtraBackup](https://www.percona.com/software/mysql-database/percona-xtrabackup) * MySQL Shell: a logical backup engine using the upstream [mysqlsh](https://dev.mysql.com/doc/mysql-shell/8.0/en/) dump/load tool (EXPERIMENTAL) ### Backup types Vitess supports full backups as well as incremental backups, and their respective counterparts full restores and point-in-time restores. * A full backup contains the entire data in the database. The backup represents a consistent state of the data, i.e. it is a snapshot of the data at some point in time. * An incremental backup contains a changelog, or a transition of data from one state to another. Vitess implements incremental backups by making a copy of MySQL binary logs. Generally speaking and on most workloads, the cost of a full backup is higher, and the cost of incremental backups is lower. The time it takes to create a full backup is significant, and it is therefore impractical to take full backups in very small intervals. Moreover, a full backup consumes the disk space needed for the entire dataset. Incremental backups, on the other hand, are quick to run, and have very little impact, if any, to the running servers. They only contain the changes in between two points in time, and on most workloads are more compact. Full and incremental backups are expected to be interleaved. For example: one would create a full backup once per day, and incremental backups once per hour. Full backups are simply states of the database. Incremental backups, however, need to start with some point and end with some point. The common practice is for an incremental backup to continue from the point of the last good backup, which can be a full or incremental backup. An inremental backup in Vitess ends at the point in time of execution. The identity of the tablet on which a full backup or an incremental backup is taken is immaterial. It is possible to take a full backup on one tablet and incremental backups on another. It is possible to take full backups on two different tablets. It is also possible to take incremental backups, independently, on two different tablets, even though the contents of those incremental backups overlaps. Vitess uses MySQL GTID sets to determine positioning and prune duplicates. ### Restores Restores are the counterparts of backups. A restore uses the engine utilized to create a backup. One may run a restore from a full backup, or a point-in-time restore (PITR) based on additional incremental backups. A Vitess 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.9669086933135986
  Content:
----------------------------------------
`xtrabackup` engine) * `--mysql-shell-speedup-restore=false` * If you are using MySQL >=8.0.21, this allows you to disable redo logs and the double write buffer for the duration of the restore, increasing the restore speed. ### Limitations and Caveats to be aware Since MySQL needs to be running for the entire backup/restore process, we can't just replace all the files like we do with the physical backups. To account for this, Vitess handles things differently: #### Databases All databases will be backed up, with the exception of `information_schema`, `mysql`, `ndbinfo`, `performance_schema` and `sys`. This is a MySQL Shell limitation. During the restore process, Vitess will drop all databases in the host ahead of the restore before starting the `mysqlsh` load process. #### Users Since user grants are stored in the `mysql` database, they are not backed up like the other databases. MySQL Shell works around that saving users separately and allow the user to pass the `loadUsers: true` option during the load process to restore users to the state they were during the backup. Internal users (`mysql.sys@localhost`, `mysql.session@localhost`, `mysql.infoschema@localhost`) are not restored, as well as the current user logged in to MySQL. It is also possible to exclude some users from being imported by using adjusting your `--mysql-shell-load-flags` if necessary. Because MySQL Shell will fail the restore if any user already exists, Vitess will drop all users in MySQL (except the ones noted above) before the restore if you specify `loadUsers: true`. ## Create a full backup with vtctl __Run the following vtctl command to create a backup:__ ```sh vtctldclient --server=<vtctld_host>:<vtctld_port> Backup [--upgrade-safe=false] <tablet-alias> ``` If the engine is `builtin`, replication will be stopped prior to shutting down mysqld for the backup. If the engine is `xtrabackup`, the tablet can continue to serve traffic while the backup is running. __Run the following vtctl command to backup a specific shard:__ ``` sh vtctldclient --server=<vtctld_host>:<vtctld_port> BackupShard [--allow_primary=false] [--upgrade-safe=false] <keyspace/shard> ``` ## Create an incremental backup with vtctl An incremental backup requires additional information: the point from which to start the backup. An incremental backup is taken by supplying `--incremental-from-pos` to the `Backup` or `BackupShard` command. The argument may either indicate: - A valid position. - A name of a successful backup. - Or, the value `auto`. ```sh vtctldclient Backup --incremental-from-pos="MySQL56/0d7aaca6-1666-11ee-aeaf-0a43f95f28a3:1-53" zone1-0000000102 vtctldclient Backup --incremental-from-pos="0d7aaca6-1666-11ee-aeaf-0a43f95f28a3:1-53" zone1-0000000102 vtctldclient Backup --incremental-from-pos="2024-01-10.062022.zone1-0000000101 commerce/0" zone1-0000000102 vtctldclient Backup --incremental-from-pos="auto" zone1-0000000102 vtctldclient BackupShard --incremental-from-pos=auto commerce/0 ``` When `--incremental-from-pos` supplies a position, you may choose to use or to omit the `MySQL56/` prefix (which you can find in the backup manifest's Position). When `--incremental-from-pos` indicates a backup name, that must be a successfully completed, existing backup. It may be either a full or an incremental backup. When `--incremental-from-pos="auto"`, Vitess chooses the position of the last successful backup as the starting point for the incremental backup. This is a convenient way to ensure a sequence of contiguous incremental backups. An incremental backup backs up one or more MySQL binary log files. These binary log files may begin with the requested position, or with 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.9472314715385437
  Content:
----------------------------------------
a subset of the SQL language. | Vitess is not a simple key-value store. It supports complex query semantics such as where clauses, JOINS, aggregation functions, and more. | | NoSQL datastores do not usually support transactions. | Vitess supports transactions. | | NoSQL solutions have custom APIs, leading to custom architectures, applications, and tools. | Vitess adds very little variance to MySQL, a database that most people are already accustomed to working with. | | NoSQL solutions provide limited support for database indexes compared to MySQL. | Vitess allows you to use all of MySQL's indexing functionality to optimize query performance. | --- title: Overview description: High-level information about Vitess weight: 1 aliases: ['/docs/overview/scalingwithvitess/','/user-guide/introduction.html'] --- The Vitess overview documentation provides general information about Vitess that's less immediately practical than what you'll find in [Get Started](../get-started) section and the [User Guides](../user-guides). --- title: Reference description: Detailed information about specific Vitess functionality weight: 5 aliases: ['/docs/advanced/'] --- --- title: Metrics description: Metrics related to backup and restore functionality weight: 10 --- Backup and restore operations export several metrics using the expvars interface. These are available at the `/debug/vars` endpoint of Vtbackup's and VTTablet's http status pages. [More details can be found here](../../features/monitoring/#3-push-based-metrics-system). ## Backup metrics Metrics related to backup operations are available in both Vtbackup and VTTablet. #### BackupBytes, BackupCount, BackupDurationNanoseconds Depending on the Backup Engine and Backup Storage in-use, a backup may be a complex pipeline of operations, including but not limited to: * Reading files from disk. * Compressing files. * Uploading compress files to cloud object storage. These operations are counted and timed, and the number of bytes consumed or produced by each stage of the pipeline are counted as well. ## Restore metrics Metrics related to restore operations are available in both Vtbackup and VTTablet. #### RestoreBytes, RestoreCount, RestoreDurationNanoseconds Depending on the Backup Engine and Backup Storage in-use, a restore may be a complex pipeline of operations, including but not limited to: * Downloading compressed files from cloud object storage. * Decompressing files. * Writing decompressed files to disk. These operations are counted and timed, and the number of bytes consumed or produced by each stage of the pipeline are counted as well. #### RestoredBackupTime, RestorePosition _RestoredBackupTime_ captures the timestamp associated with the backup from which the current process was restored. _RestorePosition_ captures the GTID position associated with that backup. ## Vtbackup metrics Vtbackup exports some metrics which are not available elsewhere. #### DurationByPhaseSeconds Vtbackup fetches the last backup, restores it to an empty mysql installation, replicates recent changes into that installation, and then takes a backup of that installation. _DurationByPhaseSeconds_ exports timings for these individual phases. <hr style="border-top: 2px dashed brown"> ## Example **A snippet of vtbackup metrics after running it against the local example after creating the initial cluster** (Processed with `jq` for readability.) ``` { "BackupBytes": { "BackupEngine.Builtin.Source:Read": 4777, "BackupEngine.Builtin.Compressor:Write": 4616, "BackupEngine.Builtin.Destination:Write": 162, "BackupStorage.File.File:Write": 163 }, "BackupCount": { "-.-.Backup": 1, "BackupEngine.Builtin.Source:Open": 161, "BackupEngine.Builtin.Source:Close": 322, "BackupEngine.Builtin.Compressor:Close": 161, "BackupEngine.Builtin.Destination:Open": 161, "BackupEngine.Builtin.Destination:Close": 322 }, "BackupDurationNanoseconds": { "-.-.Backup": 
----------------------------------------

Document 4:
  Source: Unknown
  Score: 0.8673644065856934
  Content:
----------------------------------------
as a backup engine in Vitess. Using it requires configuration using [command-line flags](https://vitess.io/docs/user-guides/operating-vitess/backup-and-restore/creating-a-backup/). ## What are my options to restore in vitess? When a tablet starts, Vitess checks the value of the `--restore_from_backup` command-line flag to determine whether to restore a backup to that tablet. - If the flag is present, Vitess tries to restore the most recent backup from the Backup Storage system when starting the tablet. - If the flag is absent, Vitess does not try to restore a backup to the tablet. The MYSQL database associated with the tablet will be empty. For more information on restoring and managing backups please follow the link [here](https://vitess.io/docs/user-guides/operating-vitess/backup-and-restore/bootstrap-and-restore/#restoring-a-backup). --- title: Configuration weight: 2 --- ## How do I connect to vtgate using MySQL protocol? In the example [vtgate-up.sh](https://github.com/vitessio/vitess/blob/main/examples/common/scripts/vtgate-up.sh) script you'll see the following lines: ```sh --mysql_server_port $mysql_server_port \ --mysql_server_socket_path $mysql_server_socket_path \ --mysql_auth_server_static_file "./mysql_auth_server_static_creds.json" \ ``` In this example, vtgate accepts MySQL connections on port 15306 and the authentication information is stored in the json file. You can then connect to it using the following command: ```sh mysql -h 127.0.0.1 -P 15306 -u mysql_user --password=mysql_password ``` ## Must the application know about the sharding scheme in Vitess? The application does not need to know about how the data is sharded. This information is stored in a VSchema which the VTGate servers use to automatically route your queries. This allows the application to connect to Vitess and use it as if it’s a single giant database server. ## Can the primary/replica be pinned to one region? Yes, you can keep a primary/replica in the primary region and can keep a read only replica in another region. ## Can data replication from a primary region cell be controlled? If you want to replicate data from a primary region cell to secondary region cell you would need to use [VReplication](https://vitess.io/docs/reference/vreplication/vreplication/). Please note that Vitess has some regulatory requirements that certain data can't leave the primary region. ## Can I change the default database name? Yes. You can start vttablet with the `-init_db_name_override` command line option to specify a different db name. There is no downside to performing this override. --- title: Kubernetes weight: 5 --- ## How does Vitess work with Kubernetes? Vitess can run as a Kubernetes-aware cloud native distributed database. This can be one of the easiest ways to run Vitess. Kubernetes handles scheduling onto nodes in a compute cluster, actively manages workloads on those nodes, and groups containers comprising an application for easy management and discovery. Vitess does not do this auto-provisioning and thus integrates nicely with Kubernetes. PlanetScale provides and supports an open-source [Kubernetes operator](https://github.com/planetscale/vitess-operator) for Vitess. ## How can I resize my Kubernetes storage when using Vitess? If you use Vitess with Kubernetes and need to grow your disk space, Kubernetes has capabilities to resize persistent storage. These are specific to your Kubernetes provider, please refer to their documentation. As an alternative, you can migrate to new storage by performing a series of planned vertical or horizontal sharding operations. 
----------------------------------------

