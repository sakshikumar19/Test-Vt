DETAILED QUERY LOG - 2025-03-15 00:51:26
======================================================================

QUESTION: How does Vitess ensure data integrity during resharding?

ANSWER: ### Vitess Data Integrity during Resharding
Vitess ensures data integrity during resharding by following these steps:
* The data in the **source shards** is copied into the **destination shards**.
* The destination shards are allowed to **catch up on replication**.
* The data in the destination shards is then **compared against the original** to ensure data integrity.
* Once the data integrity is verified, the **live serving infrastructure** is shifted to the destination shards.
* Finally, the **source shards** are deleted.

This process ensures that the data is accurately replicated and consistent across the new shard layout, maintaining data integrity throughout the resharding process.

METRICS:
  - Documents Retrieved: 3
  - Top Document Score: 0.9935630559921265
  - Response Time: 13103.18 ms
  - Retrieval Time (est.): 9172.23 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9935630559921265
  Content:
----------------------------------------
within any individual transaction. Enabling two-phase commit in Vitess to support cross-shard writes is possible, but will come at a significant performance cost. Whether that tradeoff is worth it differs from application to application and, generally speaking, adjusting the schema/workload is considered the better approach. --- title: Overview weight: 1 --- ## Why do auto-increment columns not work in sharded Vitess? Auto-increment columns do not work very well for sharded tables. Vitess sequences solve this problem. Sequence tables must be specified in the VSchema and then tied to table columns. At the time of insert, if no value is specified for such a column, VTGate will generate a number for it using the sequence table. Vitess also supports sequence generators that can be used to generate new ids that work like MySQL auto increment columns. The VSchema allows you to associate table columns to sequence tables. ## What is resharding? How does it work? Vitess supports resharding, in which the number of shards is changed on a live cluster. This can be either splitting one or more shards into smaller pieces, or merging neighboring shards into bigger pieces. During resharding, the data in the source shards is copied into the destination shards, allowed to catch up on replication, and then compared against the original to ensure data integrity. Then the live serving infrastructure is shifted to the destination shards, and the source shards are deleted. ## How are shards named? Shard names have the following characteristics: - They represent a range, where the left number is included, but the right is not. - Their notation is hexadecimal. - They are left justified. - A - prefix means: anything less than the RHS value. - A - postfix means: anything greater than or equal to the LHS value. - A plain 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.9861358404159546
  Content:
----------------------------------------
--sql-file create_customer_sharded.sql customer ``` ## Create New Shards At this point, you have finalized your sharded VSchema and vetted all the queries to make sure they still work. Now, it’s time to reshard. The resharding process works by splitting existing shards into smaller shards. This type of resharding is the most appropriate for Vitess. There are some use cases where you may want to bring up a new shard and add new rows in the most recently created shard. This can be achieved in Vitess by splitting a shard in such a way that no existing rows end up in the new shard. However, it's not natural for Vitess. We now have to create the new target shards: ### Using Operator ```bash kubectl apply -f 302_new_shards.yaml ``` </br> Make sure that you restart the port-forward after you have verified with `kubectl get pods` that this operation has completed: ```bash killall kubectl ./pf.sh & ``` ### Using a Local Deployment ```bash ./302_new_shards.sh ``` ## Start the Reshard Now we can start the [Reshard](../../../reference/vreplication/reshard/) operation. It occurs online, and will not block any read or write operations to your database: ```bash vtctldclient Reshard --target-keyspace customer --workflow cust2cust create --source-shards '0' --target-shards '-80,80-' ``` </br> All of the command options and parameters for `Reshard` are listed in our [reference page for Reshard](../../../reference/vreplication/reshard). ## Validate Correctness After the reshard is complete, we can use [VDiff](../../../reference/vreplication/vdiff) to check data integrity and ensure our source and target shards are consistent: ```bash $ vtctldclient VDiff --target-keyspace customer --workflow cust2cust create VDiff 60fa5738-9bad-11ed-b6de-920702940ee0 scheduled on target shards, use show to view progress $ vtctldclient VDiff --target-keyspace customer --workflow cust2cust show last { "Workflow": "cust2cust", "Keyspace": "customer", "State": "completed", "UUID": "60fa5738-9bad-11ed-b6de-920702940ee0", "RowsCompared": 10, "HasMismatch": false, "Shards": "-80,80-", "StartedAt": "2023-01-24 06:07:27", "CompletedAt": "2023-01-24 06:07:28" } ``` ## Switch Non-Primary Reads 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.9322295784950256
  Content:
----------------------------------------
A plain `-` denotes the full keyrange. Thus: `-80` == `00-80` == `0000-8000` == `000000-800000` == `0000000000000000-8000000000000000` `80-` is not the same as `80-FF`. This is why: `80-FF` == `8000-FF00`. Therefore `FFFF` will be out of the `80-FF` range. `80-` means: ‘anything greater than or equal to `0x80` A `xxhash` type vindex produces an unsigned 64 bit integer as output. This means that all integers **less** than `0x8000000000000000` will fall in shard `-80`. Any number with the highest bit set will be >= `0x8000000000000000`, and will therefore belong to shard `80-`. This left-justified approach allows you to have keyspace ids of arbitrary length. However, the most significant bits are the ones on the left. For example an `md5` hash produces 16 bytes. That can also be used as a keyspace id. A `varbinary` of arbitrary length can also be mapped as is to a keyspace id. This is what the `binary` vindex does. ## Resharding Vitess supports [resharding](../../user-guides/configuration-advanced/resharding), in which the number of shards is changed on a live cluster. This can be either splitting one or more shards into smaller pieces, or merging neighboring shards into bigger pieces. During resharding, the data in the source shards is copied into the destination shards, allowed to catch up on replication, and then compared against the original to ensure data integrity. Then the live serving infrastructure is shifted to the destination shards, and the source shards are deleted. **Related Vitess Documentation** * [Resharding User Guide](../../user-guides/configuration-advanced/resharding) --- title: Tablet --- A *tablet* is a combination of a `mysqld` process and a corresponding `vttablet` process, usually running on the same machine. Each tablet is assigned a *tablet type*, which specifies what role it currently performs. Queries are routed to a tablet via a [VTGate](../vtgate) server. ## Tablet Types See the user guide [VTTablet Modes](../../user-guides/configuration-basic/vttablet-mysql/) 
----------------------------------------

