DETAILED QUERY LOG - 2025-03-16 20:22:10
======================================================================

QUESTION: How does Vitess manage user-defined variables and ensure session state consistency?

ANSWER: ### Vitess Management of User-Defined Variables
Vitess manages user-defined variables by evaluating `SET` queries in the VTGate, rather than sending them to MySQL. This means that VTGate keeps the state of user-defined variables, allowing them to be used in subsequent queries.

### Ensuring Session State Consistency
To ensure session state consistency, Vitess rewrites queries that use user-defined variables before sending them to MySQL. For example, if a query uses a user-defined variable `@my_user_variable`, Vitess will rewrite the query to replace the variable with its actual value, like this:
```sql
WHERE col = 'foobar'
```
This approach eliminates the need for session state in MySQL, allowing Vitess to use connection pooling and improving performance.

### Key Benefits
The key benefits of Vitess' approach to user-defined variables include:

* **Session state consistency**: Vitess ensures that user-defined variables are handled consistently, even in a shared connection environment.
* **Connection pooling**: By evaluating `SET` queries in VTGate and rewriting queries to use actual values, Vitess can use connection pooling, improving performance and reducing the overhead of dedicated connections.
* **Simplified query execution**: Vitess' approach simplifies query execution, as MySQL does not need to maintain session state or handle user-defined variables.

METRICS:
  - Documents Retrieved: 4
  - Top Document Score: 0.9926734566688538
  - Response Time: 23353.05 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9926734566688538
  Content:
----------------------------------------
and the final result will get assembled at the vtgate level. ### Connection Pooling When a tablet talks with a MySQL to execute a query on behalf of a user, it does not use a dedicated connection per user, and instead will share the underlying connection between users. This means that it's not safe to store any state in the session as you can't be sure it will continue executing queries on the same connection, and you can't be sure if this connection will be used by other users later on. ### User-Defined Variables User defined variables are kept in the session state when working with MySQL. You can assign values to them using SET: ```sql SET @my_user_variable = 'foobar' ``` And later there can be queries using for example SELECT: ```sql > SELECT @my_user_variable; +-------------------+ | @my_user_variable | +-------------------+ | foobar | +-------------------+ ``` If you execute these queries against a VTGate, the first `SET` query is not sent to MySQL. Instead, it is evaluated in the VTGate, and VTGate will keep this state for you. The second query is also not sent down. Trivial queries such as this one are actually fully executed on VTGate. If we try a more complicated query that requires data from MySQL, VTGate will rewrite the query before sending it down. If we were to write something like: ```sql WHERE col = @my_user_variable ``` What MySQL will see is: ```sql WHERE col = 'foobar' ``` This way, no session state is needed to evaluate the query in MySQL. ### Server System Variables A user might also want to change one of the many different system variables that MySQL exposes. Vitess handles system variables in one of five different ways: * *No op*. For some settings, Vitess will just silently ignore the setting. This is for system variables that don't make much sense in a sharded setting, and don't change the behaviour of MySQL in an interesting way. * *Check and fail if not already set*. These are settings that should not change, but Vitess will allow SET statements that try to set the variable to whatever it already is. * *Not supported*. For these settings, attempting to change them will always result in an error. * *Vitess aware*. These are settings that change Vitess' behaviour, and are not sent down to MySQL * *Reserved connection*. For some settings, it makes sense to allow them to be set, but it makes using a shared connection for this user much harder. By default, Vitess will first apply these system variables that are set, and then keep the connection dedicated for this user. Connection pooling is important for the performance of Vitess, so this should not be the normal way to run applications on Vitess. Just make sure that the global variable is set to the same value the application will set it to, and Vitess can use connection pooling. Vitess now has support for connection-pooling even for these settings that originally required reserved connections. You 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.5779233574867249
  Content:
----------------------------------------
it does not actually do anything with user variables. Instead, it keeps the state in the Vitess layer. In other cases, this approach is not enough, and Vitess can use **reserved connections**. A dedicated connection is maintained for the `vtgate` session from the relevant `vttablet` to its underlying MySQL server. Reserved connections are used when using temporary tables, or when using MySQL locking functions to acquire advisory locks. In general, it is better to use reserved connections sparingly, because they reduce the effectiveness of the `vttablet` connection pooling. This may also reduce, or even eliminate, the advantages of using connection pooling between `vttablet` and MySQL. ### Reserved connections `SET` statements used to cause use of `reserved connections`. This is no longer the case with the new connection pool implementation used by vttablet. The connection pool now tracks connections with modified settings instead of pinning connections to specific client sessions. Any client requesting a connection with or without settings is provided a connection that has the correct settings. With this enhancement, we reduce the likelihood of MySQL running out of connections due to reserved connections, because the scenarios where we still need reserved connections have drastically reduced. There are still cases like [temporary tables](#temporary-tables-and-reserved-connections) and [advisory locks](#get_lock-and-reserved-connections) where reserved connections will continue to be used. ### Temporary tables and reserved connections Temporary tables exist only in the context of a particular MySQL connection. If using a temporary table, Vitess will mark the session as needing a reserved connection. It will continue to use the reserved connection until the user disconnects. Note that removing the temporary table is not enough to reset the connection. More info can be found [here](../../compatibility/mysql-compatibility/#temporary-tables). ### GET_LOCK() and reserved connections The MySQL locking functions allow users to work with user level locks. Since the locks are tied to the connection, and the lock must be released in the same connection as it was acquired, use of these functions will force a connection to become a reserved connection. This connection is also kept alive so it does not time out due to inactivity. More information can be found [here](../../../../design-docs/query-serving/locking-functions/). ### Shutting down reserved connections Whenever a connection gets transformed into a reserved connection, a fresh connection is created in the connection pool to replace it. Once the `vtgate` session that initiated the reserved connections disconnects, all reserved connections created for this session between the `vttablet`s and MySQL are terminated. You may want to configure your application or application connector to disconnect idle sessions that are likely to use reserved connections promptly. In order to release resources that cannot otherwise be reused. ### Number of vttablet <-> MySQL connections As a result of how reserved connections work, it is possible for there to be significantly more `vttablet` <-> MySQL connections than the limit you set by sizing the `vttablet` connection pools. This is because the connection pools are still being maintained. Which results in a set maximum number of connections, plus the number of reserved connections. This is at 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.4674545228481293
  Content:
----------------------------------------
can be set per query or globally. - `query_timeout_ms` (per-query timeouts). - `mysql_server_query_timeout command-line` flag (global default timeout). ### SELECT … INTO Statement Vitess supports `SELECT ... INTO DUMPFILE` and `SELECT ... INTO OUTFILE` for unsharded keyspaces: - Position of `INTO` must be at the end of the query. - For sharded keyspaces, you must specify the exact shard with a `USE` statement. ### LOAD DATA Statement `LOAD DATA` (the counterpart to `SELECT ... INTO OUTFILE`) is supported only in unsharded keyspaces: - Must be used similarly to the `SELECT ... INTO` statement. - For sharded keyspaces, use the USE Statement to target an exact shard. ### Create/Drop Database Vitess does not support `CREATE DATABASE` or `DROP DATABASE` by default: - A plugin mechanism ([`DBDDLPlugin`](https://github.com/vitessio/vitess/blob/release-21.0/go/vt/vtgate/engine/dbddl.go#L53) interface) exists for provisioning databases. - The plugin must handle database creation, topology updates, and VSchema updates. - Register the plugin with `DBDDLRegister` and specify `--dbddl_plugin=myPluginName` when running vtgate. ### User Defined Functions Vitess can track UDFs if you enable the `--enable-udfs` flag on VTGate. More details on creating UDFs can be found in the MySQL Docs. ### LAST_INSERT_ID Vitess supports `LAST_INSERT_ID` both for returning the last auto-generated ID and for the form `LAST_INSERT_ID(expr)`, which sets the session’s last-insert-id value. **Example**: ```sql insert into test (id) values (null); -- Inserts a row with an auto-generated ID select LAST_INSERT_ID(); -- Returns the last auto-generated ID SELECT LAST_INSERT_ID(123); -- Sets the session’s last-insert-id value to 123 SELECT LAST_INSERT_ID(); -- Returns 123 ``` **Limitation**: When using `LAST_INSERT_ID(expr)` as a SELECT expression in *ordered queries*, MySQL sets the session’s `LAST_INSERT_ID` value based on the *last row returned*. Vitess, however, does **not** guarantee which row’s value will be used. **Example**: ```sql SELECT LAST_INSERT_ID(col) FROM table ORDER BY foo; ``` ## Cross-shard Transactions Vitess supports multiple [transaction modes](../../../user-guides/configuration-advanced/shard-isolation-atomicity): `SINGLE`, `MULTI` and `TWOPC` . - Default: `MULTI` — multi-shard transactions on a best-effort basis. - A single-shard transaction is fully ACID-compliant. - Multi-shard commits are done in a specific order; partial commits can be manually undone if needed. ## Auto Increment Avoid the `auto_increment` column attribute in sharded keyspaces; values won’t be unique across shards. Use [Vitess Sequences](../../../user-guides) instead — they behave similarly to `auto_increment`. ## Character Set and Collation Vitess supports ~99% of MySQL collations. For details, see the [collations documentation](../../../user-guides/configuration-basic/collations). ## Data Types Vitess supports all MySQL data types. Using `FLOAT` as part of a `PRIMARY KEY` is discouraged because it can break features like filtered replication and VReplication. ## SQL Mode Vitess behaves similarly to `STRICT_TRANS_TABLES` and does not recommend changing the SQL Mode. ## Network Protocol ### Authentication Plugins Vitess supports MySQL authentication plugins, such as `mysql_native_password` and `caching_sha2_password`. ### Transport Security To enable TLS on VTGate: - Set `--mysql_server_ssl_cert` and `--mysql_server_ssl_key`. - Optionally require client certificates with `--mysql_server_ssl_ca`. - If no CA is specified, TLS is optional. ### X Dev API Vitess does not support the X Dev API. ## Workload By default, Vitess applies strict limitations on execution time and row counts, often referred to as 
----------------------------------------

Document 4:
  Source: Unknown
  Score: 0.17299656569957733
  Content:
----------------------------------------
might fetch the data from a primary database or from a replica. By routing each query to the appropriate database, Vitess allows your code to be structured as if it were reading from a single MySQL database. --- title: MoveTables --- MoveTables is a workflow based on VReplication. It enables you to relocate tables between keyspaces, and therefore physical MySQL instances, without downtime. ## Identifying Candidate Tables It is recommended to keep tables that need to join on each other in the same keyspace, so typical candidates for a MoveTables operation are a set of tables which logically group together or are otherwise isolated. If you have multiple groups of tables as candidates, which makes the most sense to move may depend on the specifics of your environment. For example, a larger table will take more time to move, but in doing so you might be able to utilize additional or newer hardware which has more headroom before you need to perform additional operations such as sharding. Similarly, tables that are updated at a more frequent rate could increase the move time. ### Impact to Production Traffic Internally, a MoveTables operation is comprised of both a table copy and a subscription to all changes made to the table. Vitess uses batching to improve the performance of both table copying and applying subscription changes, but you should expect that tables with lighter modification rates to move faster. During the active move process, data is copied from replicas instead of the primary server. This helps ensure minimal production traffic impact. During the `SwitchTraffic` phase of the MoveTables operation, for primary tablets, Vitess may be briefly unavailable. This unavailability is usually a few seconds, but will be higher in the event that your system has a high replication delay from primary to replica(s). **Related Vitess Documentation** * [MoveTables User Guide](../../user-guides/migration/move-tables) --- title: Query Rewriting --- Vitess works hard to create an illusion of the user having a single connection to a single database. In reality, a single query might interact with multiple databases and may use multiple connections to the same database. Here we'll go over what Vitess does and how it might impact you. ### Query splitting A complicated query with a cross shard join might need to first fetch information from a tablet keeping vindex lookup tables. Then use this information to query two different shards for more data and subsequently join the incoming results into a single result that the user receives. The queries that MySQL gets are often just pieces of the original query, and the final result will get assembled at the vtgate level. ### Connection Pooling When a tablet talks with a MySQL to execute a query on behalf of a user, it does not use a dedicated connection per user, and instead will share the underlying connection between users. This means that it's not safe to store any state in the session as you can't be sure it will continue executing queries on the same connection, 
----------------------------------------

