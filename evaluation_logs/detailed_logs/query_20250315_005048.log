DETAILED QUERY LOG - 2025-03-15 00:50:48
======================================================================

QUESTION: What happens if I don’t handle duplicate table names before using MoveTables?

ANSWER: ### Consequences of Not Handling Duplicate Table Names
If you don't handle duplicate table names before using MoveTables, you will encounter an error similar to: 
`ERROR 1105 (HY000): vtgate: http://localhost:15001/: ambiguous table reference`. 

This error occurs because Vitess is unable to determine which table to route queries to when there are duplicate table names. To avoid this issue, you need to export, edit, and apply routing rules to explicitly route queries to the source/original schema.

METRICS:
  - Documents Retrieved: 3
  - Top Document Score: 0.9956215023994446
  - Response Time: 12337.73 ms
  - Retrieval Time (est.): 8636.41 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9956215023994446
  Content:
----------------------------------------
title: VReplication weight: 2 --- ## How can Movetables be used with duplicate table names? If you have duplicate table names and want to use MoveTables you will need to take some action to prevent duplicate table routing issues. If you use move tables prior to following the steps below you will get an error similar to: `ERROR 1105 (HY000): vtgate: http://localhost:15001/: ambiguous table reference`. To avoid this error you need to: - Use vtctlclient GetRoutingRules and export that to a file. - Then edit that file to add specific routing to the source schema for the tables you are using. - Then use `vtctlclient ApplyRoutingRules -rules="$(cat /tmp/whatever)" ` to apply those rules. After applying those rules, queries to the tables will be explicitly routed to the source/original schema and you can use MoveTables. --- title: Sharding docs_nav_disable_expand: true weight: 5 --- --- title: Common Errors weight: 1 --- ## Why is an SQL update with a primary key slow? Using tuples in a WHERE clause can cause a MySQL slowdown. Consider: ```sql UPDATE tbl SET col=1 WHERE (pk1, pk2, pk3) IN (1,2,3), (4,5,6) ``` After a few tuples, MySQL may switch to a full table scan and lock the entire table for the duration. It should perform as expected once `FORCE INDEX (PRIMARY)` is added. You can read further information on 'FORCE INDEX' in the MySQL documentation [here](https://dev.mysql.com/doc/refman/8.0/en/index-hints.html). ## What can I do if I see a CPU increase after upgrading Vitess? If you are running Vitess 7.0 or above, we introduced the schema tracker, which could be running on the VTTablets now. You can disable it in order to prevent that reporting. You will need to add `track_schema_versions` as false in the VTTablet. ## What are the steps to take after an unplanned failover? In order to avoid 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.5931546688079834
  Content:
----------------------------------------
activity; the `MoveTables` operation is performed online: ```bash vtctldclient MoveTables --target-keyspace customer --workflow commerce2customer create --source-keyspace commerce --tables 'customer,corder' ``` A few things to note: * In a real-world situation this process can take hours or even days to complete depending on the size of the table. * The workflow name (`commerce2customer` in this case) is arbitrary, you can name it whatever you like. You will use this name for the other `MoveTables` actions like in the upcoming `SwitchTraffic` step. ## Check Routing Rules (Optional) To see what happens under the covers, let's look at the [**routing rules**](../../../reference/features/schema-routing-rules/) that the `MoveTables` operation created. These are instructions used by a [`VTGate`](../../../concepts/vtgate) to determine which backend keyspace to send requests to for a given table — even when using a fully qualified table name such as `commerce.customer`: ```json $ vtctldclient GetRoutingRules { "rules": [ { "fromTable": "customer.customer@rdonly", "toTables": [ "commerce.customer" ] }, { "fromTable": "commerce.corder@rdonly", "toTables": [ "commerce.corder" ] }, { "fromTable": "customer", "toTables": [ "commerce.customer" ] }, { "fromTable": "customer.customer@replica", "toTables": [ "commerce.customer" ] }, { "fromTable": "corder@replica", "toTables": [ "commerce.corder" ] }, { "fromTable": "customer.corder", "toTables": [ "commerce.corder" ] }, { "fromTable": "commerce.corder@replica", "toTables": [ "commerce.corder" ] }, { "fromTable": "customer@rdonly", "toTables": [ "commerce.customer" ] }, { "fromTable": "commerce.customer@replica", "toTables": [ "commerce.customer" ] }, { "fromTable": "corder", "toTables": [ "commerce.corder" ] }, { "fromTable": "corder@rdonly", "toTables": [ "commerce.corder" ] }, { "fromTable": "customer.corder@rdonly", "toTables": [ "commerce.corder" ] }, { "fromTable": "customer@replica", "toTables": [ "commerce.customer" ] }, { "fromTable": "customer.customer", "toTables": [ "commerce.customer" ] }, { "fromTable": "commerce.customer@rdonly", "toTables": [ "commerce.customer" ] }, { "fromTable": "customer.corder@replica", "toTables": [ "commerce.corder" ] } ] } ``` The `MoveTables` operation has created [routing rules](../../../reference/features/schema-routing-rules/) to explicitly route queries against the `customer` and `corder` tables — including the fully qualified `customer.customer` and `customer.corder` names — 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.5735828876495361
  Content:
----------------------------------------
range, where the left number is included, but the right is not. - Their notation is hexadecimal. - They are left justified. - A - prefix means: anything less than the RHS value. - A - postfix means: anything greater than or equal to the LHS value. - A plain - denotes the full keyrange. An example of a shard name is `-80` and following the rules above this means: `-80` == `00-80` == `0000-8000` == `000000-800000` Similarly `80-` is not the same as `80-FF` because `80-FF` == `8000-FF00`. Therefore `FFFF` will be out of the `80-FF` range as `80-` means: ‘anything greater than or equal to `0x80` A hash vindex produces an 8-byte number. This means that all numbers less than `0x8000000000000000` will fall in shard `-80`. Any number with the highest bit set will be >= `0x8000000000000000`, and will therefore belong to shard `80-`. ## What does “/0” or “/-”mean? `0` or `-` indicates that the keyspace in question is unsharded. This means that a single shard covers the entire keyrange. Note that while both `0` and `-` are supported for legacy reasons, you can’t merge into shard `0` only `-`. For this and other reasons, it is recommended to use `-` instead of `0`. On the other hand a sharded cluster will have multiple keyranges, for example `-80` and `80-` if you have two shards. Note, that you can still manually target a single shard from your sharded cluster. You can read more about that [here](https://vitess.io/docs/faq/operating-vitess/queries/#can-i-address-a-specific-shard-if-i-want-to). --- title: VReplication weight: 2 --- ## How can Movetables be used with duplicate table names? If you have duplicate table names and want to use MoveTables you will need to take some action to prevent duplicate table routing issues. If you use move tables prior to following the steps below 
----------------------------------------

