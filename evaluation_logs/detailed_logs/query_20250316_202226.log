DETAILED QUERY LOG - 2025-03-16 20:22:26
======================================================================

QUESTION: What are the five ways Vitess handles MySQL system variables, and can you provide examples of each?

ANSWER: ### Vitess Handling of MySQL System Variables
Vitess handles MySQL system variables in five different ways:

1. **No op**: For some settings, Vitess will just silently ignore the setting. This is for system variables that don't make much sense in a sharded setting, and don't change the behaviour of MySQL in an interesting way.
2. **Check and fail if not already set**: These are settings that should not change, but Vitess will allow SET statements that try to set the variable to whatever it already is.
3. **Not supported**: For these settings, attempting to change them will always result in an error.
4. **Vitess aware**: These are settings that change Vitess' behaviour, and are not sent down to MySQL.
5. **Reserved connection**: For some settings, it makes sense to allow them to be set, but it makes using a shared connection for this user much harder. By default, Vitess will first apply these system variables that are set, and then keep the connection dedicated for this user.

Unfortunately, the provided context does not include specific examples of each of these five ways. To provide more detailed examples, additional information about the specific system variables and their handling in Vitess would be necessary.

METRICS:
  - Documents Retrieved: 4
  - Top Document Score: 0.9986281394958496
  - Response Time: 16195.96 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9986281394958496
  Content:
----------------------------------------
and the final result will get assembled at the vtgate level. ### Connection Pooling When a tablet talks with a MySQL to execute a query on behalf of a user, it does not use a dedicated connection per user, and instead will share the underlying connection between users. This means that it's not safe to store any state in the session as you can't be sure it will continue executing queries on the same connection, and you can't be sure if this connection will be used by other users later on. ### User-Defined Variables User defined variables are kept in the session state when working with MySQL. You can assign values to them using SET: ```sql SET @my_user_variable = 'foobar' ``` And later there can be queries using for example SELECT: ```sql > SELECT @my_user_variable; +-------------------+ | @my_user_variable | +-------------------+ | foobar | +-------------------+ ``` If you execute these queries against a VTGate, the first `SET` query is not sent to MySQL. Instead, it is evaluated in the VTGate, and VTGate will keep this state for you. The second query is also not sent down. Trivial queries such as this one are actually fully executed on VTGate. If we try a more complicated query that requires data from MySQL, VTGate will rewrite the query before sending it down. If we were to write something like: ```sql WHERE col = @my_user_variable ``` What MySQL will see is: ```sql WHERE col = 'foobar' ``` This way, no session state is needed to evaluate the query in MySQL. ### Server System Variables A user might also want to change one of the many different system variables that MySQL exposes. Vitess handles system variables in one of five different ways: * *No op*. For some settings, Vitess will just silently ignore the setting. This is for system variables that don't make much sense in a sharded setting, and don't change the behaviour of MySQL in an interesting way. * *Check and fail if not already set*. These are settings that should not change, but Vitess will allow SET statements that try to set the variable to whatever it already is. * *Not supported*. For these settings, attempting to change them will always result in an error. * *Vitess aware*. These are settings that change Vitess' behaviour, and are not sent down to MySQL * *Reserved connection*. For some settings, it makes sense to allow them to be set, but it makes using a shared connection for this user much harder. By default, Vitess will first apply these system variables that are set, and then keep the connection dedicated for this user. Connection pooling is important for the performance of Vitess, so this should not be the normal way to run applications on Vitess. Just make sure that the global variable is set to the same value the application will set it to, and Vitess can use connection pooling. Vitess now has support for connection-pooling even for these settings that originally required reserved connections. You 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.9741490483283997
  Content:
----------------------------------------
that are set, and then keep the connection dedicated for this user. Connection pooling is important for the performance of Vitess, so this should not be the normal way to run applications on Vitess. Just make sure that the global variable is set to the same value the application will set it to, and Vitess can use connection pooling. Vitess now has support for connection-pooling even for these settings that originally required reserved connections. You can read more about it [here](../../reference/query-serving/reserved-conn/#settings-pool-and-reserved-connections). In addition to this, Vitess makes sure that @@version includes both the emulated MySQL version and the Vitess version, such as: `5.7.9-vitess-14.0.0`. This value can be changed by using the vtgate flag `--mysql_server_version`. ### Special functions There are a few special functions that Vitess handles without delegating to MySQL. * `DATABASE()` - The keyspace name and the underlying database names do not have to be equal. Vitess will rewrite these calls to use the literal string for the keyspace name. (This also applies to the synonym `SCHEMA()`) * `ROW_COUNT()` and `FOUND_ROWS()` - These functions returns how many rows the last query affected/returned. Since this might have been executed on a different connection, these get rewritten to use the literal value of the number of returned rows. * `LAST_INSERT_ID()` - Much like `FOUND_ROWS()`, we can't trust a pooled connection for these function calls, so they get rewritten before hitting MySQL. ### Reference Here is a list of all the system variables that are handled by Vitess and how they are handled. | *System variable* | *Handled* | |-----------------------------------------|----------------| | autocommit | VitessAware | | client_found_rows | VitessAware | | skip_query_plan_cache | VitessAware | | tx_read_only | VitessAware | | transaction_read_only | VitessAware | | sql_select_limit | VitessAware | | transaction_mode | VitessAware | | ddl_strategy | VitessAware | | foreign_key_checks | VitessAware | | workload | VitessAware | | charset | VitessAware | | names | VitessAware | | session_uuid | VitessAware | | migration_context | VitessAware | | enable_system_settings | VitessAware | | read_after_write_gtid | VitessAware | | read_after_write_timeout | VitessAware | | session_track_gtids | VitessAware | | query_timeout | VitessAware | | transaction_isolation | VitessAware | | tx_isolation | VitessAware | | big_tables | NoOp | | bulk_insert_buffer_size | NoOp | | debug | NoOp | | default_storage_engine | NoOp | | default_tmp_storage_engine | NoOp | | innodb_strict_mode | NoOp | | innodb_support_xa | NoOp | | innodb_table_locks | NoOp | | innodb_tmpdir | NoOp | | join_buffer_size | NoOp | | keep_files_on_create | NoOp | | lc_messages | NoOp | | long_query_time | NoOp | | low_priority_updates | NoOp | | max_delayed_threads | NoOp | | max_insert_delayed_threads | NoOp | | multi_range_count | NoOp | | net_buffer_length | NoOp | | new | NoOp | | query_cache_type | NoOp | | query_cache_wlock_invalidate | NoOp | | query_prealloc_size | NoOp | | sql_buffer_result | NoOp | | transaction_alloc_block_size | NoOp | | wait_timeout | NoOp | | audit_log_read_buffer_size | NotSupported | | auto_increment_increment | NotSupported | | auto_increment_offset 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.7943633198738098
  Content:
----------------------------------------
What Is Vitess weight: 1 featured: true --- Vitess is a database solution for deploying, scaling and managing large clusters of open-source database instances. It currently supports MySQL and Percona Server for MySQL. It's architected to run as effectively in a public or private cloud architecture as it does on dedicated hardware. It combines and extends many important SQL features with the scalability of a NoSQL database. Vitess can help you with the following problems: 1. Scaling a SQL database by allowing you to shard it, while keeping application changes to a minimum. 2. Migrating from bare-metal or VMs to a private or public cloud. 3. Deploying and managing a large number of SQL database instances. Vitess includes compliant JDBC and Go database drivers using a native query protocol. Additionally, it implements the MySQL server protocol which is compatible with virtually any other language. Vitess served all YouTube database traffic for over five years. Many enterprises have now adopted Vitess for their production needs. ## Features * Performance - Connection pooling - Multiplex front-end application queries onto a pool of MySQL connections to optimize performance. - Query de-duping – Reuse results of an in-flight query for any identical requests received while the in-flight query was still executing. - Transaction manager – Limit number of concurrent transactions and manage timeouts to optimize overall throughput. * Protection - Query rewriting and sanitization – Add limits and avoid non-deterministic updates. - Query blocking – Customize rules to prevent potentially problematic queries from hitting your database. - Query killing – Terminate queries that take too long to return data. - Table ACLs – Specify access control lists (ACLs) for tables based on the connected user. * Monitoring - Performance analysis tools let you monitor, diagnose, and analyze your database performance. * Topology Management Tools - Cluster management tools (handles planned and unplanned failovers) - Web-based management GUI - Designed to work in multiple data centers / regions * Sharding - Virtually seamless dynamic re-sharding - Vertical and Horizontal sharding support - Multiple sharding schemes, with the ability to plug-in custom ones ## Comparisons to other storage options The following sections compare Vitess to two common alternatives, a vanilla MySQL implementation and a NoSQL implementation. ### Vitess vs. Vanilla MySQL Vitess improves a vanilla MySQL implementation in several ways: | Vanilla MySQL | Vitess | |:--|:--| | Every MySQL connection has a memory overhead that ranges between 256KB and almost 3MB, depending on which MySQL release you're using. As your user base grows, you need to add RAM to support additional connections, but the RAM does not contribute to faster queries. In addition, there is a significant CPU cost associated with obtaining the connections. | Vitess creates very lightweight connections. Vitess' connection pooling feature uses Go's concurrency support to map these lightweight connections to a small pool of MySQL connections. As such, Vitess can easily handle thousands of connections. | | Poorly written queries, such as those that don't set a LIMIT, can negatively impact 
----------------------------------------

Document 4:
  Source: Unknown
  Score: 0.7882381677627563
  Content:
----------------------------------------
is a Unicode-aware database, and as explained on [the MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/charset-mysql.html), it supports using many different character sets to store textual data in databases, and many different collations which are used to compare and sort this textual data. Likewise, Vitess is also Unicode-aware, and it supports the vast majority of the collations and charsets in the underlying MySQL server. On a basic level, this support means that Vitess handles gracefully textual Unicode columns and queries, and relays this information to MySQL clients without losing or corrupting the encoding of the data. On top of this, newer versions of Vitess are also capable of performing textual comparison and sorting operations in SQL queries directly on VTGate instances, greatly speeding up complex operations such as cross-shard joins. ### Supported collations The collation environment (i.e. the set of support collations and charsets) of a Vitess cluster is defined by the MySQL server version flag (`--mysql_server_version`) provided to the VTGate and VTTablet instances in the cluster. Higher (newer) MySQL versions will enable built-in support for more collations. The following table lists all of the supported collations in the current release of Vitess: | Legend | | |----|----| | ✅ | Vitess has full support for this collation. | | ⚠️ | The underlying MySQL (or compatible) database supports this collation, but Vitess does not. | | ❌ | Neither Vitess nor the underlying MySQL database supports this collation. | Using collations that are not supported by Vitess but implemented in the underlying MySQL instance can lead to unpredictable behavior. | Collation | Charset | MySQL 8.0 | MySQL 5.7 | MySQL 5.6 | MariaDB 10.3 | MariaDB 10.2 | MariaDB 10.1 | MariaDB 10.0 | |---|---|---|---|---|---|---|---|---| | big5_chinese_ci | big5 | ⚠️ | ⚠️ | ⚠️ | ⚠️ | ⚠️ | ⚠️ | ⚠️ | | latin2_czech_cs | latin2 | ⚠️ | ⚠️ | ⚠️ | ⚠️ | ⚠️ | ⚠️ | ⚠️ | | dec8_swedish_ci | dec8 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | | cp850_general_ci | cp850 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | | latin1_german1_ci | latin1 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | | hp8_english_ci | hp8 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | | koi8r_general_ci | koi8r | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | | latin1_swedish_ci | latin1 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | | latin2_general_ci | latin2 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | | swe7_swedish_ci | swe7 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | | ascii_general_ci | ascii | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | | ujis_japanese_ci | ujis | ✅ | ✅ | 
----------------------------------------

