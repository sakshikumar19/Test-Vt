DETAILED QUERY LOG - 2025-03-16 20:21:10
======================================================================

QUESTION: What is connection pooling in Vitess, and why is it important for performance?

ANSWER: ### Connection Pooling in Vitess
Connection pooling in Vitess refers to the practice of reusing existing database connections to improve performance. 

### Importance of Connection Pooling
Connection pooling is important for the performance of Vitess because it reduces the overhead of creating new connections. If connections are not pooled, Vitess would need to create a new connection for each query, which can lead to performance issues. 

### Reserved Connections
In the past, certain settings required Vitess to use reserved connections, which meant that a connection would be dedicated to a specific user and not be reused. However, Vitess now supports connection pooling even for these settings, allowing for better performance. 

To take advantage of connection pooling, it's essential to ensure that the global variable is set to the same value as the application, so Vitess can reuse connections. You can read more about connection pooling and reserved connections [here](../../reference/query-serving/reserved-conn/#settings-pool-and-reserved-connections).

METRICS:
  - Documents Retrieved: 4
  - Top Document Score: 0.9923974871635437
  - Response Time: 19262.27 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9923974871635437
  Content:
----------------------------------------
that are set, and then keep the connection dedicated for this user. Connection pooling is important for the performance of Vitess, so this should not be the normal way to run applications on Vitess. Just make sure that the global variable is set to the same value the application will set it to, and Vitess can use connection pooling. Vitess now has support for connection-pooling even for these settings that originally required reserved connections. You can read more about it [here](../../reference/query-serving/reserved-conn/#settings-pool-and-reserved-connections). In addition to this, Vitess makes sure that @@version includes both the emulated MySQL version and the Vitess version, such as: `5.7.9-vitess-14.0.0`. This value can be changed by using the vtgate flag `--mysql_server_version`. ### Special functions There are a few special functions that Vitess handles without delegating to MySQL. * `DATABASE()` - The keyspace name and the underlying database names do not have to be equal. Vitess will rewrite these calls to use the literal string for the keyspace name. (This also applies to the synonym `SCHEMA()`) * `ROW_COUNT()` and `FOUND_ROWS()` - These functions returns how many rows the last query affected/returned. Since this might have been executed on a different connection, these get rewritten to use the literal value of the number of returned rows. * `LAST_INSERT_ID()` - Much like `FOUND_ROWS()`, we can't trust a pooled connection for these function calls, so they get rewritten before hitting MySQL. ### Reference Here is a list of all the system variables that are handled by Vitess and how they are handled. | *System variable* | *Handled* | |-----------------------------------------|----------------| | autocommit | VitessAware | | client_found_rows | VitessAware | | skip_query_plan_cache | VitessAware | | tx_read_only | VitessAware | | transaction_read_only | VitessAware | | sql_select_limit | VitessAware | | transaction_mode | VitessAware | | ddl_strategy | VitessAware | | foreign_key_checks | VitessAware | | workload | VitessAware | | charset | VitessAware | | names | VitessAware | | session_uuid | VitessAware | | migration_context | VitessAware | | enable_system_settings | VitessAware | | read_after_write_gtid | VitessAware | | read_after_write_timeout | VitessAware | | session_track_gtids | VitessAware | | query_timeout | VitessAware | | transaction_isolation | VitessAware | | tx_isolation | VitessAware | | big_tables | NoOp | | bulk_insert_buffer_size | NoOp | | debug | NoOp | | default_storage_engine | NoOp | | default_tmp_storage_engine | NoOp | | innodb_strict_mode | NoOp | | innodb_support_xa | NoOp | | innodb_table_locks | NoOp | | innodb_tmpdir | NoOp | | join_buffer_size | NoOp | | keep_files_on_create | NoOp | | lc_messages | NoOp | | long_query_time | NoOp | | low_priority_updates | NoOp | | max_delayed_threads | NoOp | | max_insert_delayed_threads | NoOp | | multi_range_count | NoOp | | net_buffer_length | NoOp | | new | NoOp | | query_cache_type | NoOp | | query_cache_wlock_invalidate | NoOp | | query_prealloc_size | NoOp | | sql_buffer_result | NoOp | | transaction_alloc_block_size | NoOp | | wait_timeout | NoOp | | audit_log_read_buffer_size | NotSupported | | auto_increment_increment | NotSupported | | auto_increment_offset 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.9812784790992737
  Content:
----------------------------------------
What Is Vitess weight: 1 featured: true --- Vitess is a database solution for deploying, scaling and managing large clusters of open-source database instances. It currently supports MySQL and Percona Server for MySQL. It's architected to run as effectively in a public or private cloud architecture as it does on dedicated hardware. It combines and extends many important SQL features with the scalability of a NoSQL database. Vitess can help you with the following problems: 1. Scaling a SQL database by allowing you to shard it, while keeping application changes to a minimum. 2. Migrating from bare-metal or VMs to a private or public cloud. 3. Deploying and managing a large number of SQL database instances. Vitess includes compliant JDBC and Go database drivers using a native query protocol. Additionally, it implements the MySQL server protocol which is compatible with virtually any other language. Vitess served all YouTube database traffic for over five years. Many enterprises have now adopted Vitess for their production needs. ## Features * Performance - Connection pooling - Multiplex front-end application queries onto a pool of MySQL connections to optimize performance. - Query de-duping – Reuse results of an in-flight query for any identical requests received while the in-flight query was still executing. - Transaction manager – Limit number of concurrent transactions and manage timeouts to optimize overall throughput. * Protection - Query rewriting and sanitization – Add limits and avoid non-deterministic updates. - Query blocking – Customize rules to prevent potentially problematic queries from hitting your database. - Query killing – Terminate queries that take too long to return data. - Table ACLs – Specify access control lists (ACLs) for tables based on the connected user. * Monitoring - Performance analysis tools let you monitor, diagnose, and analyze your database performance. * Topology Management Tools - Cluster management tools (handles planned and unplanned failovers) - Web-based management GUI - Designed to work in multiple data centers / regions * Sharding - Virtually seamless dynamic re-sharding - Vertical and Horizontal sharding support - Multiple sharding schemes, with the ability to plug-in custom ones ## Comparisons to other storage options The following sections compare Vitess to two common alternatives, a vanilla MySQL implementation and a NoSQL implementation. ### Vitess vs. Vanilla MySQL Vitess improves a vanilla MySQL implementation in several ways: | Vanilla MySQL | Vitess | |:--|:--| | Every MySQL connection has a memory overhead that ranges between 256KB and almost 3MB, depending on which MySQL release you're using. As your user base grows, you need to add RAM to support additional connections, but the RAM does not contribute to faster queries. In addition, there is a significant CPU cost associated with obtaining the connections. | Vitess creates very lightweight connections. Vitess' connection pooling feature uses Go's concurrency support to map these lightweight connections to a small pool of MySQL connections. As such, Vitess can easily handle thousands of connections. | | Poorly written queries, such as those that don't set a LIMIT, can negatively impact 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.9625389575958252
  Content:
----------------------------------------
additional connections, but the RAM does not contribute to faster queries. In addition, there is a significant CPU cost associated with obtaining the connections. | Vitess creates very lightweight connections. Vitess' connection pooling feature uses Go's concurrency support to map these lightweight connections to a small pool of MySQL connections. As such, Vitess can easily handle thousands of connections. | | Poorly written queries, such as those that don't set a LIMIT, can negatively impact database performance for all users. | Vitess employs a SQL parser that uses a configurable set of rules to rewrite queries that might hurt database performance. | | Sharding is a process of partitioning your data to improve scalability and performance. MySQL lacks native sharding support, requiring you to write sharding code and embed sharding logic in your application. | Vitess supports a variety of sharding schemes. It can also migrate tables into different databases and scale the number of shards up or down. These functions are performed non-intrusively, completing most data transitions with just a few seconds of read-only downtime. | | A MySQL cluster using replication for availability has a primary database and a few replicas. If the primary fails, a replica should become the new primary. This requires you to manage the database lifecycle and communicate the current system state to your application. | Vitess helps to manage the lifecycle of your database servers. It supports and automatically handles various scenarios, including primary failure detection and recovery. It also has support for data backups and restores. | | A MySQL cluster can have custom database configurations for different workloads, like a primary database for writes, fast read-only replicas for web clients, slower read-only replicas for batch jobs, and so forth. If the database has horizontal sharding, the setup is repeated for each shard, and the app needs baked-in logic to know how to find the right database. | Vitess uses a topology backed by a consistent data store, like etcd or ZooKeeper. This means the cluster view is always up-to-date and consistent for different clients. Vitess also provides a proxy that routes queries efficiently to the most appropriate MySQL instance. | ### Vitess vs. NoSQL If you're considering a NoSQL solution primarily because of concerns about the scalability of MySQL, Vitess might be a more appropriate choice for your application. While NoSQL provides great support for unstructured data, Vitess still offers several benefits not available in NoSQL datastores: | NoSQL | Vitess | |:--|:--| | NoSQL databases do not define relationships between database tables, and only support a subset of the SQL language. | Vitess is not a simple key-value store. It supports complex query semantics such as where clauses, JOINS, aggregation functions, and more. | | NoSQL datastores do not usually support transactions. | Vitess supports transactions. | | NoSQL solutions have custom APIs, leading to custom architectures, applications, and tools. | Vitess adds very little variance to MySQL, a database that most people are already accustomed to working with. | 
----------------------------------------

Document 4:
  Source: Unknown
  Score: 0.7668222188949585
  Content:
----------------------------------------
to protect the situation where a client has crashed without completing a transaction. Typical value for this timeout is 30s. * `queryserver-config-idle-timeout`: This value sets a time in seconds after which, if a connection has not been used, this connection will be removed from pool. This effectively manages number of connection objects and optimizes the pool performance. * `queryserver-config-max-result-size`: This parameter prevents the OLTP application from accidentally requesting too many rows. If the result exceeds the specified number of rows, VTTablet returns an error. The default value is 10,000. Here is a typical vttablet invocation: ```text vttablet <topo_flags> <backup_flags> \ --log_dir=${VTDATAROOT}/tmp \ --cell=cell1 \ --tablet-path=cell1-100 \ --init_keyspace=commerce \ --init_shard=0 \ --init_tablet_type=replica \ --port=15100 \ --grpc_port=16100 \ --service_map 'grpc-queryservice,grpc-tabletmanager’ \ --enable_replication_reporter=true \ --restore_from_backup=true \ --queryserver-config-pool-size=16 \ --queryserver-config-transaction-cap=300 \ --queryserver-config-stream-pool-size= 16 ``` ### Key configuration notes * It is important to set MySQL’s `max_connections` property to be 50%-100% higher than the total number of connections in the various pools. * This is because Vitess may have to kill connections and open new ones. MySQL accounting has a delay in how it counts closed connections, which may cause its view of the number of connections to exceed the ones currently opened by Vitess. For example, in the above example, the `max_connections` settings should be around 800. * It is also important to set vttablets `queryserver-config-idle-timeout` to be at least 10% lower than MySQL's `wait_timeout`. * This is because MySQL's `wait_timeout` is the number of seconds the server waits for activity on a noninteractive connection before closing it. So if the vttablet setting is not lower the MySQL limit will be hit first and can cause issues with performance. The defaults are as follows: `queryserver-config-idle-timeout` defaults to 30 minutes and MySQL's `wait_timeout` defaults to 8 hours. It is normal to see errors like these in the log file until MySQL instances have been initialized and a vttablet has been elected as primary: ```text 2020-04-27T00:38:02.040081Z 2 [Note] Aborted connection 2 to db: 'unconnected' user: 'root' host: 'localhost' (Got an error reading communication packets) ``` Starting the first vttablet against a keyspace and shard performs the following actions: * Create a keyspace and shard in the global topo if these did not exist before. * Perform a [RebuildKeyspaceGraph](../../../reference/programs/vtctl/keyspaces/#rebuildkeyspacegraph) to deploy the global topo to the current cell (cell1). * Create a tablet record, which will allow vtgates to discover it. * No restore action will be performed because this is the first time vttablet is coming up and no backups exist yet. The vttablet will be unhealthy because the database for the keyspace has not been created. Visiting the `/debug/status` page on its port should show the following information: ![unhealthy-tablet](../img/unhealthy-tablet.png) The next step is to bring up the rest of the vttablet-MySQL pairs on other machines or different ports of the same machine. ## Tablet Records You can find out the current state of all vttablets with the following command: ```sh $ vtctldclient GetTablets cell1-0000000100 commerce 0 primary sougou-lap1:15100 sougou-lap1:17100 [] 2021-01-02T22:27:11Z cell1-0000000101 commerce 0 replica 
----------------------------------------

