DETAILED QUERY LOG - 2025-03-15 00:52:13
======================================================================

QUESTION: How do I apply routing rules in Vitess to handle duplicate table names?

ANSWER: ### Applying Routing Rules in Vitess to Handle Duplicate Table Names
To apply routing rules in Vitess and handle duplicate table names, you can follow these steps:

1. **Get the current routing rules**: Use `vtctlclient GetRoutingRules` and export the output to a file.
2. **Edit the routing rules file**: Add specific routing to the source schema for the tables you are using.
3. **Apply the updated routing rules**: Use `vtctlclient ApplyRoutingRules -rules="$(cat /tmp/your_file)"` to apply the updated rules.

By applying these routing rules, queries to the tables will be explicitly routed to the source/original schema, allowing you to use `MoveTables` without encountering duplicate table routing issues.

METRICS:
  - Documents Retrieved: 3
  - Top Document Score: 0.9929177761077881
  - Response Time: 11614.64 ms
  - Retrieval Time (est.): 8130.25 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9929177761077881
  Content:
----------------------------------------
title: VReplication weight: 2 --- ## How can Movetables be used with duplicate table names? If you have duplicate table names and want to use MoveTables you will need to take some action to prevent duplicate table routing issues. If you use move tables prior to following the steps below you will get an error similar to: `ERROR 1105 (HY000): vtgate: http://localhost:15001/: ambiguous table reference`. To avoid this error you need to: - Use vtctlclient GetRoutingRules and export that to a file. - Then edit that file to add specific routing to the source schema for the tables you are using. - Then use `vtctlclient ApplyRoutingRules -rules="$(cat /tmp/whatever)" ` to apply those rules. After applying those rules, queries to the tables will be explicitly routed to the source/original schema and you can use MoveTables. --- title: Sharding docs_nav_disable_expand: true weight: 5 --- --- title: Common Errors weight: 1 --- ## Why is an SQL update with a primary key slow? Using tuples in a WHERE clause can cause a MySQL slowdown. Consider: ```sql UPDATE tbl SET col=1 WHERE (pk1, pk2, pk3) IN (1,2,3), (4,5,6) ``` After a few tuples, MySQL may switch to a full table scan and lock the entire table for the duration. It should perform as expected once `FORCE INDEX (PRIMARY)` is added. You can read further information on 'FORCE INDEX' in the MySQL documentation [here](https://dev.mysql.com/doc/refman/8.0/en/index-hints.html). ## What can I do if I see a CPU increase after upgrading Vitess? If you are running Vitess 7.0 or above, we introduced the schema tracker, which could be running on the VTTablets now. You can disable it in order to prevent that reporting. You will need to add `track_schema_versions` as false in the VTTablet. ## What are the steps to take after an unplanned failover? In order to avoid 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.871002733707428
  Content:
----------------------------------------
here we specify the `--cell` flag so that cell's topo base path — stored in its `CellInfo` record in the `global` topo — is used: ```bash $ vtctldclient --server=localhost:15999 GetTopologyPath /global/cells/zone1/CellInfo { "name": "CellInfo", "path": "/global/cells/zone1/CellInfo", "data": "server_address:\"localhost:2379\" root:\"/vitess/zone1\"", "children": [] } $ vtctldclient --server=localhost:15999 GetTopologyPath /zone1/keyspaces/commerce/SrvKeyspace { "name": "SrvKeyspace", "path": "/zone1/keyspaces/commerce/SrvKeyspace", "data": "partitions:{served_type:PRIMARY shard_references:{name:\"0\"}} partitions:{served_type:REPLICA shard_references:{name:\"0\"}} partitions:{served_type:RDONLY shard_references:{name:\"0\"}}", "children": [] } ``` ## Routing Rules [Routing Rules](../../../features/schema-routing-rules) are stored in the `RoutingRules` key within the `global` topo. Routing Rules contain a list of table-specific routes. You can route a table for all or specific tablet types to another table in the same or different keyspace. Here is an example using the same commerce keyspace where we have an active [`MoveTables`](../../../vreplication/movetables/) workflow to move tables to the customer keyspace but we have not switched any traffic yet: ```bash $ vtctldclient --server=localhost:15999 GetTopologyPath /global/RoutingRules { "name": "RoutingRules", "path": "/global/RoutingRules", "data": "rules:{from_table:\"customer.customer\" to_tables:\"commerce.customer\"} rules:{from_table:\"commerce.customer@rdonly\" to_tables:\"commerce.customer\"} rules:{from_table:\"corder\" to_tables:\"commerce.corder\"} rules:{from_table:\"corder@replica\" to_tables:\"commerce.corder\"} rules:{from_table:\"corder@rdonly\" to_tables:\"commerce.corder\"} rules:{from_table:\"customer.corder\" to_tables:\"commerce.corder\"} rules:{from_table:\"customer\" to_tables:\"commerce.customer\"} rules:{from_table:\"customer@rdonly\" to_tables:\"commerce.customer\"} rules:{from_table:\"customer.corder@replica\" to_tables:\"commerce.corder\"} rules:{from_table:\"commerce.customer@replica\" to_tables:\"commerce.customer\"} rules:{from_table:\"customer.customer@replica\" to_tables:\"commerce.customer\"} rules:{from_table:\"customer.customer@rdonly\" to_tables:\"commerce.customer\"} rules:{from_table:\"commerce.corder@rdonly\" to_tables:\"commerce.corder\"} rules:{from_table:\"customer@replica\" to_tables:\"commerce.customer\"} rules:{from_table:\"commerce.corder@replica\" to_tables:\"commerce.corder\"} rules:{from_table:\"customer.corder@rdonly\" to_tables:\"commerce.corder\"}", "children": [] } ``` </br> {{< info >}} In practice you would instead typically view the routing rules via the dedicated [`GetRoutingRules`](../../../programs/vtctldclient/vtctldclient_getroutingrules/) vtctl client command which will return the rules for all keyspaces in the topo. {{< /info >}} # How VTGate Routes a Query This section walks through a simplified version of the logic used to determine which keyspace and table vtgate will route a simple query of the form `select * from t1 where id = 1` (a _read_ query) or `insert into t1 (id, val) values (1,'abc')` (a _write_ query). 1. Check to see if `t1` has an appropriate routing rule defined. If so, use the specified target table as an alias for `t1`. 2. Locate 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.8495302796363831
  Content:
----------------------------------------
true } ``` This flag causes VTGate to automatically expand expressions like `select *` or insert statements that don’t specify the column list. The caveat about using this feature is that you have to keep this column list in sync with the underlying schema. #### Automatic Schema Tracking Vtgates now also have the capability to track the schema changes and populate the columns list on its own by contacting the vttablets. To know more about this feature, read [here](../../../reference/features/schema-tracking). This feature tracks the underlying schema and sets the authoritative column list. ## Routing Rules Routing Rules are an advanced method of redirecting queries meant for one table to another. They are just pointers and are analogous to symbolic links in a file system. You should generally not have to use routing rules in Vitess. Workflows like `MoveTables` make use of routing rules to create the existence of the target tables and manage traffic switch from source to target by manipulating these routing rules. For more information, please refer to the [Routing Rules](../../../reference/features/schema-routing-rules) section. ## Foreign Key Mode Vitess supports multiple foreign key modes. A detailed analysis of these different modes can be found on the [foreign keys](../foreign-keys) page. Each keyspace can be configured to run with a different foreign key mode - ```json { "sharded": true, "foreignKeyMode": "managed" } ``` --- title: Backfill Lookup Vindexes weight: 11 --- Creating a Lookup Vindex after the main table already contains rows does not automatically backfill the lookup table for the existing entries. Only newer inserts cause automatic population of the lookup table. This backfill can be set up using the [LookupVindex create](../../../reference/programs/vtctldclient/vtctldclient_lookupvindex/vtctldclient_lookupvindex_create/) command covered below. ### Manual Backfill Checklist Creating a unique Lookup Vindex is an elaborate process. It is good to use the following checklist if this is done manually: * 
----------------------------------------

