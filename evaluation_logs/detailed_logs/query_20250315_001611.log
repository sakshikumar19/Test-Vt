DETAILED QUERY LOG - 2025-03-15 00:16:11
======================================================================

QUESTION: How do I create a VSchema for a sharded keyspace?

ANSWER: ### Creating a VSchema for a Sharded Keyspace
To create a VSchema for a sharded keyspace, you need to specify the primary Vindex for each table. The primary Vindex determines the sharding key and strategy for the table.

#### Steps to Create a VSchema:

1. **Determine the Sharding Key**: Identify a clear sharding key, which is a column that is present in most tables in your data model. Common sharding keys include user ID or customer ID.
2. **Specify the Primary Vindex**: Specify the primary Vindex for each table, which defines the sharding key and strategy.
3. **Define the VSchema**: Define the VSchema using the `ApplyVSchema` command, specifying the primary Vindex for each table.

#### Example:
Suppose you have a table `users` with a column `user_id` that you want to use as the sharding key. You can create a VSchema using the following command:
```json
{
  "sharded": true,
  "tables": {
    "users": {
      "primary_vindex": {
        "column": "user_id",
        "type": "hash"
      }
    }
  }
}
```
You can then apply this VSchema using the `ApplyVSchema` command:
```bash
ApplyVSchema --vschema=<vschema> <keyspace>
```
Replace `<vschema>` with the JSON definition of your VSchema, and `<keyspace>` with the name of your keyspace.

Note that the ease of creation of a VSchema depends heavily on how your data model is constructed. For more complex data models, you may need to investigate the patterns of common queries to determine the optimal sharding keys.

METRICS:
  - Documents Retrieved: 3
  - Top Document Score: 0.9979829788208008
  - Response Time: 20228.4 ms
  - Retrieval Time (est.): 14159.88 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9979829788208008
  Content:
----------------------------------------
primary key. Every sharded table must have one defined. A Primary Vindex must be unique: given an input value, it must produce a single keyspace ID. At the time of an insert to the table, the unique mapping produced by the Primary Vindex determines the target shard for the inserted row. In Vitess, the choice of Vindex allows control of how a column value maps to a keyspace ID. In other words, a Primary Vindex in Vitess not only defines the Sharding Key, but also decides the Sharding Strategy. Uniqueness for a Primary Vindex does not mean that the column has to be a primary key or unique key in the MySQL schema for the underlying shard. You can have multiple rows that map to the same keyspace ID. The Vindex uniqueness constraint only ensures that all rows for a keyspace ID end up in the same shard. ## How do I create a VSchema? The ease of creation of a VSchema depends heavily on now your data model is constructed. For some data models, especially smaller and less complex ones, it can be less challenging to determine how to split the data between shards. A clear sharding key would be a column that is on most of the tables in your data model. If there is a clear sharding key then creating VSchema is as straightforward as specifying that column as the primary Vindex for each table. Common primary Vindexes tend to be user ID or customer ID. For more complex data models most will have to investigate the patterns of common queries in order to determine what sharding keys to use. When investigating the most common queries you must identify what you want to optimize, as this influences heavily the determination of the sharding keys. For example if 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.9966334700584412
  Content:
----------------------------------------
Commands You can use the following commands for maintaining the VSchema: * `GetVSchema <keyspace>` * `ApplyVSchema -- {--vschema=<vschema> || --vschema_file=<vschema file> || --sql=<sql> || --sql_file=<sql file>} [--cells=c1,c2,...] [--skip_rebuild] [--dry-run] [--strict] <keyspace>` * `RebuildVSchemaGraph [--cells=c1,c2,...]` * `GetSrvVSchema <cell>` * `DeleteSrvVSchema <cell>` In order to verify that a VTGate has loaded SrvVSchema correctly, you can visit the `/debug/vschema` URL on the VTGate's http port. ### Unsharded Table The following snippets show the necessary configs for creating a table in an unsharded keyspace: Schema: ``` sql # lookup keyspace create table name_user_idx(name varchar(128), user_id bigint, primary key(name, user_id)); ``` VSchema: ``` json // lookup keyspace { "sharded": false, "tables": { "name_user_idx": {} } } ``` For a normal unsharded table, the VSchema only needs to know the table name. No additional metadata is needed. ### Sharded Table With Simple Primary Vindex To create a sharded table with a simple [Primary Vindex](../vindexes/#the-primary-vindex), the VSchema requires more information: Schema: ``` sql # user keyspace create table user(user_id bigint, name varchar(128), primary key(user_id)); ``` VSchema: ``` json // user keyspace { "sharded": true, "vindexes": { "xxhash": { "type": "xxhash" } }, "tables": { "user": { "column_vindexes": [ { "column": "user_id", "name": "xxhash" } ] } } } ``` Because Vindexes can be shared, the JSON requires them to be specified in a separate `vindexes` section, and then referenced by name from the `tables` section. The VSchema above simply states that `user_id` uses `xxhash` as Primary Vindex. The first Vindex of every table must be the Primary Vindex. ### Specifying A Sequence Since user is a sharded table, it will be beneficial to tie it to a Sequence. However, the sequence must be defined in the lookup (unsharded) keyspace. It is then referred from the user (sharded) keyspace. In this example, we are designating the `user_id` (Primary 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.9957616925239563
  Content:
----------------------------------------
Primary Vindex is unique: given an input value, it produces a single keyspace ID, or value in the keyspace used to shard the table. The Primary Vindex is typically a functional Vindex: Vitess computes the keyspace ID as needed from a column in the sharded table. ## Sequences Auto-increment columns do not work very well for sharded tables. [Vitess sequences](../vitess-sequences) solve this problem. Sequence tables must be specified in the VSchema, and then tied to table columns. At the time of insert, if no value is specified for such a column, VTGate will generate a number for it using the sequence table. ## Reference tables Vitess allows you to create an unsharded table and deploy it into all shards of a sharded keyspace. The data in such a table is assumed to be identical for all shards. In this case, you can specify that the table is of type `reference`, and should not specify any vindex for it. Any joins of this table with an unsharded table will be treated as a local join. Typically, such a table has a canonical source in an unsharded keyspace, and the copies in the sharded keyspace are kept up-to-date through VReplication. ## Per-Keyspace VSchema The VSchema uses a flexible proto JSON format. Essentially, you can use `snake_case` or `camelCase` for the keys. The configuration of your VSchema reflects the desired sharding configuration for your database, including whether or not your tables are sharded and whether you want to implement a secondary Vindex. ### Commands You can use the following commands for maintaining the VSchema: * `GetVSchema <keyspace>` * `ApplyVSchema -- {--vschema=<vschema> || --vschema_file=<vschema file> || --sql=<sql> || --sql_file=<sql file>} [--cells=c1,c2,...] [--skip_rebuild] [--dry-run] [--strict] <keyspace>` * `RebuildVSchemaGraph [--cells=c1,c2,...]` * `GetSrvVSchema <cell>` * `DeleteSrvVSchema <cell>` In order to verify that a VTGate has loaded SrvVSchema 
----------------------------------------

