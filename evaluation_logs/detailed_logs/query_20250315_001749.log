DETAILED QUERY LOG - 2025-03-15 00:17:49
======================================================================

QUESTION: How do I configure semi-synchronous replication in Vitess?

ANSWER: ### Configuring Semi-Synchronous Replication in Vitess
Vitess strongly recommends the use of semi-synchronous replication for high availability. To configure semi-synchronous replication in Vitess, you need to ensure that the following conditions are met:

1. **Row-Based Replication with GTIDs enabled**: Vitess requires the use of Row-Based Replication with GTIDs enabled. This is a requirement for semi-synchronous replication in Vitess.
2. **Default `binlog_row_image` of `FULL`**: Vitess only supports the default `binlog_row_image` of `FULL`.
3. **Durability Policy configured for the keyspace**: The characteristics of semi-sync are replication governed by the [Durability Policy](../../../user-guides/configuration-basic/durability_policy) configured for the keyspace.

#### Semi-Synchronous Replication Characteristics
Vitess configures the semi-sync timeout to essentially an unlimited number, so it will never fall back to asynchronous replication. This prevents split brain (or alternate futures) in case of a network partition.

Additionally, all pre-configured durability policies do not allow tablets of type `rdonly` to send semi-sync ACKs, as they are not eligible to be promoted to primary.

#### Example Configuration
The exact configuration for semi-synchronous replication in Vitess may vary depending on your specific use case and Vitess setup. It's recommended to consult the Vitess documentation and seek guidance from a Vitess expert before configuring semi-synchronous replication.

Note that Vitess provides a built-in mechanism for semi-synchronous replication, and the configuration is largely governed by the Durability Policy configured for the keyspace. Therefore, the primary step is to ensure that the Durability Policy is correctly configured for your use case.

METRICS:
  - Documents Retrieved: 3
  - Top Document Score: 0.9963808655738831
  - Response Time: 20229.29 ms
  - Retrieval Time (est.): 14160.5 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9963808655738831
  Content:
----------------------------------------
Vitess plans * You can use a special `SELECT` query to see the next value from a sequence: ```sql select next value from user_seq; ``` --- title: Replication weight: 9 aliases: ['/docs/reference/row-based-replication/','/docs/reference/vitess-replication/','/docs/reference/mysql-replication/'] --- {{< warning >}} Vitess requires the use of Row-Based Replication with GTIDs enabled. In addition, Vitess only supports the default `binlog_row_image` of `FULL`. {{< /warning >}} Vitess makes use of MySQL Replication for both high availability and to receive a feed of changes to database tables. This feed is then used in features such as [VReplication](../../vreplication/vreplication/), and to identify schema changes so that caches can be updated. ## Semi-Sync Vitess strongly recommends the use of Semi-synchronous replication for High Availability. The characteristics of semi-sync are replication governed by the [Durability Policy](../../../user-guides/configuration-basic/durability_policy) configured for the keyspace. Some characteristics are shared by all the policies - * Vitess configures the semi-sync timeout to essentially an unlimited number so that it will never fallback to asyncronous replication. This is important to prevent split brain (or alternate futures) in case of a network partition. If we can verify all replicas have stopped replicating, we know the old primary is not accepting writes, even if we are unable to contact the old primary itself. * All pre-configured durability policies do not allow tablets of type rdonly to send semi-sync ACKs. This is intentional because rdonly tablets are not eligible to be promoted to primary, so Vitess avoids the case where a rdonly tablet is the single best candidate for election at the time of primary failure. Having semi-sync enabled, gives you the property that, in case of primary failure, there is at least one other replica that has every transaction that was ever reported to clients as having completed. You can then wait for [VTOrc](../../../user-guides/configuration-basic/vtorc) to repair it, or ([manually](../../programs/vtctl/shards/#emergencyreparentshard) pick the 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.9665370583534241
  Content:
----------------------------------------
time of primary failure. Having semi-sync enabled, gives you the property that, in case of primary failure, there is at least one other replica that has every transaction that was ever reported to clients as having completed. You can then wait for [VTOrc](../../../user-guides/configuration-basic/vtorc) to repair it, or ([manually](../../programs/vtctl/shards/#emergencyreparentshard) pick the replica that is farthest ahead in GTID position and promote that to be the new primary. Thus, you can survive sudden primary failure without losing any transactions that were reported to clients as completed. In MySQL 5.7+, this guarantee is strengthened slightly to preventing loss of any transactions that were ever **committed** on the original primary, eliminating so-called [phantom reads](http://bugs.mysql.com/bug.php?id=62174). On the other hand these behaviors also give a requirement that each shard must have at least 2 tablets with type *replica* (with addition of the primary that can be demoted to type *replica* this gives a minimum of 3 tablets with initial type *replica*). This will allow for the primary to have a semi-sync acker when one of the replica tablets is down for any reason (for a version update, machine reboot, or anything else). These requirements will changed based on the durability policy. With regard to replication lag, note that this does **not** guarantee there is always at least one replica from which queries will always return up-to-date results. Semi-sync guarantees that at least one replica has the transaction in its relay log, but it has not necessarily been applied yet. The only way Vitess guarantees a fully up-to-date read is to send the request to the primary. ## MySQL Replication Modes Vitess requires the use of [Row-Based Replication (RBR)](https://dev.mysql.com/doc/refman/en/replication-formats.html) with [GTIDs](https://dev.mysql.com/doc/refman/en/replication-gtids.html) enabled: [`--binlog-row-format=ROW`](https://dev.mysql.com/doc/refman/en/replication-options-binary-log.html#sysvar_binlog_format) and [`--gtid-mode=ON`](https://dev.mysql.com/doc/refman/en/replication-options-gtids.html#sysvar_gtid_mode). Vitess also recommends [`FULL`](https://dev.mysql.com/doc/refman/en/replication-options-binary-log.html#sysvar_binlog_row_image) binary log images in order to support all manner of transformations in [VReplication workflows](../../vreplication/vreplication/), but in v17 we 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.9604745507240295
  Content:
----------------------------------------
replication if it is not running. ## What is semi-sync replication? Semi-sync replication enables you to prevent your primary from acknowledging a transaction to the client until a replica confirms that it has received all the changes. This adds an extra guarantee that at least one other machine has a copy of the changes. This addresses the problem of a combination of lagging replication and network issues resulting in data loss. With semi-sync replication, even if you have network issues you shouldnâ€™t lose your data. Please do note that when using semi-sync replication you will have to wait for your data to flow from the primary to the replica and then get a confirmation back to the primary. Thus each transaction may take longer. The length of time depends on the round trip time from the primary to the replica. ## Why would I use semi-sync replication? Semi-sync replication ensures data durability between the primary and at least one replica. Hardware failures are unavoidable but don't need to result in data loss if you run with semi-sync replication. --- title: Advanced Configuration docs_nav_disable_expand: true weight: 10 --- --- title: Compatibility weight: 2 --- ## What versions of MySQL or MariaDB work with Vitess? Please refer to our [Supported Databases](https://vitess.io/docs/overview/supported-databases/) for the most up-to-date information. ## What does it mean to say that Vitess "is MySQL compatible"? Will my application "just work"? Vitess supports much of MySQL, with some limitations. **Depending on your MySQL setup you will need to adjust queries that utilize any of the current unsupported cases.** For SQL syntax there is a list of example [unsupported queries](https://github.com/vitessio/vitess/blob/main/go/vt/vtgate/planbuilder/testdata/unsupported_cases.json). There are some further [compatibility issues](https://vitess.io/docs/reference/mysql-compatibility/) beyond pure SQL syntax. ## How is Vitess different from MySQL? MySQL is a popular open source database solution. MySQL delivers a fast, multi-threaded, multi-user, 
----------------------------------------

