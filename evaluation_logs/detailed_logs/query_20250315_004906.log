DETAILED QUERY LOG - 2025-03-15 00:49:06
======================================================================

QUESTION: Can I perform cross-shard JOINs or transactions in Vitess?

ANSWER: ### Cross-Shard JOINs and Transactions in Vitess
Yes, Vitess does allow you to perform both cross-shard joins and transactions. However, it's essential to note that a sharded architecture will perform best if you design it well and play to its strength, e.g., favoring single-shard targeted writes within any individual transaction.

Enabling two-phase commit in Vitess to support cross-shard writes is possible, but it will come at a significant performance cost. Whether that tradeoff is worth it differs from application to application, and generally speaking, adjusting the schema/workload is considered the better approach.

METRICS:
  - Documents Retrieved: 3
  - Top Document Score: 0.9993329644203186
  - Response Time: 21677.14 ms
  - Retrieval Time (est.): 15173.99 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9993329644203186
  Content:
----------------------------------------
- You need to prevent your SQL client from stripping the comments before sending to the server (the MySQL CLI strips comments by default) - You need to disable query normalization in vtgate (`--normalize_queries false`); to allow the comment to reach vttablet. - It only works for SELECT statements today, this might change in the future. {{< info >}} Note that streaming queries are not affected by either of these timeouts. {{< /info >}} ## Can I increase the resource pool timeout for streaming requests? Yes. You can adjust the vttablet flag for this. For example: `--queryserver-config-stream-pool-timeout=1s`. --- title: Operating Vitess docs_nav_disable_expand: true weight: 3 --- --- title: Advanced weight: 3 --- ## How can I know which shard contains a row for a table? You can use the primary Vindex column to query the Vindex and discover the shard ID. Once you have determined the shard ID you can use [manual shard targeting](http://vitess.io/docs/faq/operating-vitess/queries/?#can-i-address-a-specific-shard-if-i-want-to) to send that specific shard a query. Note that if the query contains the primary Vindex column, or an appropriate secondary Vindex column, you do not need to do this, and vtgate can route the query automatically. ## Can I use Vitess to do cross-shard JOINs or Transactions? A horizontal sharding solution for MySQL like Vitess does allow you to do both cross-shard joins and transactions, but just because you can doesn’t mean you should. A sharded architecture will perform best if you design it well and play to its strength, e.g. favoring single-shard targeted writes within any individual transaction. Enabling two-phase commit in Vitess to support cross-shard writes is possible, but will come at a significant performance cost. Whether that tradeoff is worth it differs from application to application and, generally speaking, adjusting the schema/workload is considered the better approach. --- title: Overview weight: 1 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.9943605065345764
  Content:
----------------------------------------
it stayed together. Or, if your database is extremely small. However, if you reach a point where the data is starting to grow, sharding may become inevitable. ### Moving Tables Typically, the first step you may perform is to split your database by moving some tables on to other databases. In Vitess parlance, we call this as splitting off keyspaces. The [MoveTables](../../migration/move-tables) workflow allows you to perform this with minimal impact to the application. ### Resharding Beyond a certain point, it may not make sense to separate tables that are strongly related to each other. This is when resharding comes into play. Choosing the “sharding key” is often intuitively obvious. If you analyze the query pattern in the application, the query with the highest QPS will dictate the sharding key (or Primary Vindex). In our example below, we will be choosing `customer_id` as the Primary Vindex for the `customer` table. If there are queries with other where clauses on the same table, those would be candidates for secondary lookup vindexes. ### Joins The next criteria to take into account are joins. If you are performing joins across tables, it will be beneficial to keep those rows together. In our example, we will be keeping the rows of the order table along with their customer. This grouping will allow us to efficiently perform operations like reading all orders placed by a customer. ### Transactions It is important to keep transactions within a single shard whenever possible. Grouping related rows together usually results in transactions also falling within the same shard, but there are situations where this may not be possible. For such use-cases, Vitess supports [configurable atomicity levels for transactions that go across shards](../../configuration-advanced/shard-isolation-atomicity). In the cases where a cross-shard transaction simply cannot be avoided, the [usage of 2PC](../../../reference/features/distributed-transaction/) allows for 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.9631165266036987
  Content:
----------------------------------------
modify a [subset of system settings](https://github.com/vitessio/vitess/blob/main/go/vt/sysvars/sysvars.go#L174-L217) on the MySQL. ## Calculating maximum db connections used by vttablet You can use the following formula to approximate the maximum MySQL connections per vttablet instance: ``` --queryserver-config-transaction-cap x 2 (transaction_pool and found_rows_pool) + --queryserver-config-pool-size (conn_pool) + --queryserver-config-stream-pool-size (stream_conn_pool) + --dba_pool_size (dba_conn_pool) + --app_pool_size (app_conn_pool) + 3 (tx_read_pool, hardcoded) + 7 (online DDL) + variable (on demand: for vreplication, MySQL replication, etc; should < 10) + variable (reserved connections used by `enable_system_settings`) ``` {{< info >}} Note that most servers will not use this many connections, since most workloads do not exercise all the pools. {{< /info >}} --- title: Distributed Transactions weight: 11 aliases: ['/docs/launching/twopc/','/docs/reference/two-phase-commit/','/docs/reference/distributed-transaction/'] --- # Distributed Transactions in Vitess ## Overview A distributed transaction is an operation that spans multiple database shards while maintaining data consistency. Vitess supports distributed transactions through a Two-Phase Commit (TwoPC) protocol, allowing you to perform atomic updates across different shards in your database cluster. > **Performance Note:** Using atomic distributed transactions will impact commit latency. > We recommend designing your VSchema to minimize cross-shard updates where possible. ## Transaction Modes Vitess supports three levels of transaction atomicity, each offering different guarantees and performance characteristics: | Mode | Description | Use Case | Guarantees | |------|-------------|----------|-----------| | Single | Transactions limited to one shard | Simple CRUD operations | Full ACID | | Multi | Can span multiple shards with best-effort commits | Bulk updates where partial success is acceptable | No atomicity | | TwoPC | Atomic commits across multiple shards | Financial transactions, inventory updates | Atomic commits | ### When to Use TwoPC Choose TwoPC when you need guaranteed atomic commits across shards, such as: - Financial transactions where partial commits could lead to inconsistent balances - Inventory systems where items must be updated 
----------------------------------------

