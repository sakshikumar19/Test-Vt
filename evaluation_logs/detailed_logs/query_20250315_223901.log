DETAILED QUERY LOG - 2025-03-15 22:39:01
======================================================================

QUESTION: What should I do if my Vitess primary starts up in read-only mode?

ANSWER: ### Resolving Vitess Primary Read-Only Mode
If your Vitess primary starts up in read-only mode, you can resolve the issue by using the `SetReadWrite` command. This command will convert the primary to read-write mode.

Alternatively, if VTOrc is running, it will automatically take care of converting the primary to read-write mode.

**Important Considerations:**

* If the primary was restarted due to an unexpected issue, it's recommended to reparent to a different replica using the `EmergencyReparentShard` command.
* For planned maintenance on the primary, reparent to another replica using the `PlannedReparentShard` command before performing maintenance.

By taking these steps, you can resolve the read-only mode issue and ensure your Vitess primary is functioning correctly.

METRICS:
  - Documents Retrieved: 4
  - Top Document Score: 0.9943268895149231
  - Response Time: 19266.23 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9943268895149231
  Content:
----------------------------------------
--- title: Elevated query latency on primary description: Debug common issues with Vitess weight: 1 --- ## Elevated query latency on primary Diagnosis 1: Inspect the graphs to see if QPS has gone up. If yes, drill down on the more detailed QPS graphs to see which table, or user caused the increase. If a table is identified, look at /debug/queryz for queries on that table. Action: Inform engineer about the toxic queries. If it’s a specific user, you can stop their job or throttle them to keep the load manageable. As a last resort, blacklist query to allow the rest of the system to stay healthy. Diagnosis 2: QPS did not go up, only latency did. Inspect the per-table latency graphs. If it’s a specific table, then it’s most likely a long-running low QPS query that’s skewing the numbers. Identify the culprit query and take necessary steps to get it optimized. Such queries usually do not cause outage. So, there may not be a need to take extreme measures. Diagnosis 3: Latency seems to be up across the board. Inspect transaction latency. If this has gone up, then something is causing MySQL to run too many concurrent transactions which causes slow-down. See if there are any tx pool full errors. If there is an increase, the INFO logs will dump info about all transactions. From there, you should be able to if a specific sequence of statements is causing the problem. Once that is identified, find out the root cause. It could be network issues, or it could be a recent change in app behavior. Diagnosis 4: No particular transaction seems to be the culprit. Nothing seems to have changed in any of the requests. Look at system variables to see if there are hardware faults. Is the disk latency too high? Are there memory parity errors? If so, you may have to failover to a new machine. --- title: Primary starts up read-only description: Debug common issues with Vitess weight: 5 --- ## Primary starts up read-only To prevent accidentally accepting writes, our default my.cnf settings tell MySQL to always start up read-only. If the primary MySQL gets restarted, it will thus come back read-only until someone intervene to confirm that it should accept writes. If VTOrc is running, then it will take care of converting the primary to read-write mode. However, to fix manually, you can use the [`SetReadWrite`](../../reference/programs/vtctl/tablets/#setreadwrite) command to do that. Usually if something unexpected happens to the primary, it's better to reparent to a different replica with [`EmergencyReparentShard`](../../reference/programs/vtctl/shards/#emergencyreparentshard). If you need to do planned maintenance on the primary, it's best to first reparent to another replica with [`PlannedReparentShard`](../../reference/programs/vtctl/shards/#plannedreparentshard). --- title: Vitess sees the wrong tablet as primary description: Debug common issues with Vitess weight: 10 --- ## Vitess sees the wrong tablet as primary If you do a failover manually (not through Vitess), you'll need to tell Vitess which tablet corresponds to the new primary MySQL. Until then, writes will fail since they'll be 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.9815952777862549
  Content:
----------------------------------------
errors If you see the following error string `The MySQL server is running with the --read-only option so it cannot execute this statement (errno 1290) (sqlstate HY000)` while trying to write to the primary, then it likely means that a previous `PlannedReparentShard` operation failed in the middle. Re-executing `PlannedReparentShard` against that primary should fix the problem. If this operation fails with an error saying that there is no current primary, you may have to issue an `EmergencyReparentShard` to safely elect a primary. If VTOrc is running, no action is needed because VTOrc will notice this state and fix it in a safe manner. This error can also be encountered if a new primary has been elected, but the older vttablet continues to think that it is still the primary. If this is the situation, then it is transient and will heal itself as long as components are able to communicate with each other. In this situation, the older vttablet will be in read-only mode. VTGates that are trying to send the writes to it will fail. Eventually, the new primary will inform the vtgates of its existence, and they will start sending traffic to the new primary instead of the old one. The old primary will also eventually notice that a new primary was elected. When it notices it, it will demote itself to a replica. ### Local TopoServer of a Cell is getting overloaded This situation can happen if a large number of vtgates continuously spam the local toposerver to check for changes in the list of tablet servers. If this is the case, you may have to reduce the polling frequency of the vtgates by reducing the `--tablet_refresh_interval` value. ### Global Topo or Cell Topo is down Vitess servers are built to survive brief topo outages in the order of many minutes. All Vitess servers cache the necessary information to serve traffic. If there is an outage, they use the cached information to continue serving traffic. However, during such an outage, you may not be able to perform cluster maintenance operations like a reparent, resharding, or bringing up new servers. ### Topo Complete Data Loss In the unforeseen circumstance of a total data loss of the topo servers, a Vitess cluster can be restored to an operational state by performing the following actions: * Bring up a brand new set of empty topo servers. * Recreate the cell info as before. * Restart all the vttablets. * Upload the VSchema for the recreated keyspaces. If you are in the middle of a reshard, make sure you restart the source vttablets first. This order will ensure that they get marked as serving. Any shards that get added later that overlap with existing keyranges will be marked as non-serving. --- title: vtctld weight: 5 --- vtctld is not required to be highly available because it is not in the serving path of a query. Nevertheless, it may be wise to bring up more than a single instance. Typically, users bring 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.9096061587333679
  Content:
----------------------------------------
you need to do planned maintenance on the primary, it's best to first reparent to another replica with [`PlannedReparentShard`](../../reference/programs/vtctl/shards/#plannedreparentshard). --- title: Vitess sees the wrong tablet as primary description: Debug common issues with Vitess weight: 10 --- ## Vitess sees the wrong tablet as primary If you do a failover manually (not through Vitess), you'll need to tell Vitess which tablet corresponds to the new primary MySQL. Until then, writes will fail since they'll be routed to a read-only replica (the old primary). Use the [`TabletExternallyReparented`](../../reference/programs/vtctl/shards/#tabletexternallyreparented) command to tell Vitess the new primary tablet for a shard. Older versions of Vitess supported tools like [Orchestrator](https://github.com/github/orchestrator), which can be configured to call this automatically when a failover occurs. See our sample [orchestrator.conf.json](https://github.com/vitessio/vitess/blob/1129d69282bb738c94b8af661b984b6377a759f7/docker/orchestrator/orchestrator.conf.json#L131) for an example of this. --- title: Troubleshoot aliases: ['/docs/launching/troubleshooting/'] description: Debug common issues with Vitess weight: 2600 --- If there is a problem in the system, one or many alerts would typically fire. If a problem was found through means other than an alert, then the alert system needs to be iterated upon. When an alert fires, you have the following sources of information to perform your investigation: * Alert values * Graphs * Diagnostic URLs * Log files ### Find version of Vitess build ``` select @@version; ```
----------------------------------------

Document 4:
  Source: Unknown
  Score: 0.412905752658844
  Content:
----------------------------------------
a given VTTablet you will need to perform the following steps: 1. Create the new user in the database. 2. Give that user the required permissions. The list of what Vitess requires can be found [here](https://github.com/vitessio/vitess/blob/master/config/init_db.sql). 3. Then when you start up Vitess you need to pass in the username and passwords to Vitess. That is done by setting `--db_user` and `--db-credentials-file`. The credentials file will have the format: ```sh { "<user name>": [ "<password>" ] } ``` After you have followed the above steps the credentials file will tell VTTablet the account to use to connect to the database. You can read additional details on the credentials file format [here](https://github.com/vitessio/vitess/blob/master/examples/local/mysql_auth_server_static_creds.json). ## If mysqld replication thread isn't running what restarts it? VTOrc will automatically restart replication if it is not running. ## What is semi-sync replication? Semi-sync replication enables you to prevent your primary from acknowledging a transaction to the client until a replica confirms that it has received all the changes. This adds an extra guarantee that at least one other machine has a copy of the changes. This addresses the problem of a combination of lagging replication and network issues resulting in data loss. With semi-sync replication, even if you have network issues you shouldn’t lose your data. Please do note that when using semi-sync replication you will have to wait for your data to flow from the primary to the replica and then get a confirmation back to the primary. Thus each transaction may take longer. The length of time depends on the round trip time from the primary to the replica. ## Why would I use semi-sync replication? Semi-sync replication ensures data durability between the primary and at least one replica. Hardware failures are unavoidable but don't need to result in data loss if you run with semi-sync replication. --- title: Advanced Configuration docs_nav_disable_expand: true weight: 10 --- --- title: Compatibility weight: 2 --- ## What versions of MySQL or MariaDB work with Vitess? Please refer to our [Supported Databases](https://vitess.io/docs/overview/supported-databases/) for the most up-to-date information. ## What does it mean to say that Vitess "is MySQL compatible"? Will my application "just work"? Vitess supports much of MySQL, with some limitations. **Depending on your MySQL setup you will need to adjust queries that utilize any of the current unsupported cases.** For SQL syntax there is a list of example [unsupported queries](https://github.com/vitessio/vitess/blob/main/go/vt/vtgate/planbuilder/testdata/unsupported_cases.json). There are some further [compatibility issues](https://vitess.io/docs/reference/mysql-compatibility/) beyond pure SQL syntax. ## How is Vitess different from MySQL? MySQL is a popular open source database solution. MySQL delivers a fast, multi-threaded, multi-user, and robust SQL (Structured Query Language) database server. However, MySQL starts running into limitations with large data sizes or large numbers of concurrent users. Vitess is a database scaling system designed to be used with MySQL. It enables deploying, scaling and managing large clusters of MySQL instances with built-in sharding, high availability and connection pooling. ## How is Vitess different from RDS for MySQL? RDS for MySQL is a managed service from AWS which has 
----------------------------------------

