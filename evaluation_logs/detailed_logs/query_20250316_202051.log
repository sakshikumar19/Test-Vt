DETAILED QUERY LOG - 2025-03-16 20:20:51
======================================================================

QUESTION: What is the purpose of a keyspace in Vitess, and how does it differ between sharded and unsharded setups?

ANSWER: ### Keyspace in Vitess
A keyspace in Vitess is the equivalent of a MySQL database. It serves as a logical view of the data, allowing for horizontal scaling of MySQL.

### Purpose of a Keyspace
The purpose of a keyspace is to provide a way to organize and manage data in Vitess, making it possible to scale MySQL databases horizontally.

### Sharded vs Unsharded Keyspace
A keyspace can be either sharded or unsharded:
* **Unsharded Keyspace**: In an unsharded setup, a keyspace directly corresponds to a physical MySQL server with a single database. The VSchema for an unsharded keyspace is a simple list of table names.
* **Sharded Keyspace**: In a sharded setup, a single keyspace maps to multiple MySQL servers behind the scenes. The VSchema for a sharded keyspace contains additional metadata about the sharding scheme for each table and how they relate to each other.

In summary, the purpose of a keyspace in Vitess is to provide a logical view of the data, and it can be either sharded or unsharded, depending on the scaling requirements of the database.

METRICS:
  - Documents Retrieved: 4
  - Top Document Score: 0.9876512289047241
  - Response Time: 12122.35 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9876512289047241
  Content:
----------------------------------------
topology. In this logical view, a Vitess keyspace is the equivalent of a MySQL database. In many cases, this is a one-to-one mapping where a keyspace directly corresponds to a physical MySQL server with a single database. However, a Vitess keyspace can also be sharded. If so, a single keyspace would map to multiple MySQL servers behind the scenes. The topology is typically spread across multiple Topo Servers: The Global Topo server contains global information, like the list of keyspaces, shards and cells. This information gets deployed into cell-specific topo servers. Each cell-specific Topo Server contains additional information about vttablets and MySQL servers running in that cell. With this architecture, an outage in one cell does not affect other cells. The topo also stores a VSchema for each keyspace. For an unsharded keyspace, the vschema is a simple list of table names. If a keyspace is sharded, then it must contain additional metadata about the sharding scheme for each table, and how they relate to each other. When a query is received by VTGate, the information in the vschema is used to make decisions about how to serve the query. In some cases, it will result in the query being routed to a single shard. In other cases, it could result in the query being sent to all shards, etc. This guide explains how to build vschemas for Vitess keyspaces. ### Demo To illustrate the various features of the VSchema, we will make use of the [demo app](https://github.com/vitessio/vitess/tree/main/examples/demo). After installing Vitess, you can launch this demo by running `go run demo.go`. Following this, you can visit http://localhost:8000 to view the tables, issue arbitrary queries, and view their effects. Alternatively, you can also connect to Vitess using a MySQL client: `mysql -h 127.0.0.1 -P 12348`. The demo models a set of tables that are similar to those presented in the [Getting Started](../../../get-started/local) guide, but with more focus on the VSchema. Note that the demo brings up a test process called vtcombo (instead of a real Vitess cluster), which is functionally equivalent to all the components of Vitess, but within a single process. You can also use the demo app to follow the steps of this user guide. If so, you can start by emptying out the files under `schema/product` and `schema/customer`, and incrementally making the changes presented in the steps that follow. ### VSchema DDL The demo describes the VSchema JSON syntax. Many of the changes can be executed by issuing special DDL commands that Vitess understands. Wherever applicable, we have provided the equivalent DDL construct you could apply if you were running a live system. All the DDLs are also listed in the [vschema_ddls.sql](https://github.com/vitessio/vitess/blob/main/examples/demo/vschema_ddls.sql) file. It is generally recommended that you get familiar with the JSON syntax as it will be useful for troubleshooting if something does not work as intended. --- title: Pictorial Summary weight: 25 --- The following two diagrams highlight some of the relationships that exist between VSchema elements and the MySQL tables. ### product and customer 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.9872856736183167
  Content:
----------------------------------------
on how you optimized your sharding keys. ## When do I need to use a VSchema? For a very trivial setup where there is only one unsharded keyspace, there is no need to specify a VSchema because Vitess will know that there is nowhere to route a query except to the single shard. However, once you have sharding, having a VSchema becomes a necessity. This is because a VSchema is needed to locate and place rows in each table in a sharded keyspace. The Vitess distribution has a demo of VSchema operation [here](https://github.com/vitessio/vitess/tree/master/examples/demo). --- title: Getting Started docs_nav_disable_expand: true weight: 1 --- --- title: Advanced Migrations weight: 2 --- ## How do I migrate to Vitess from a hosted MySQL? If you are running a hosted MySQL like RDS on AWS, CloudSQL on GCP, or Azure managed MySQL, because you are not coming from MySQL you have to use either the ‘Stop-the-world’ method or the method using VReplication setup in front of the existing external database. You can read more about those two methods [here](https://vitess.io/docs/user-guides/migration/migrate-data/). There is no option to do an application level migration. The biggest challenge with this sort of migration is you must be able to access the source database from the location where you want to put the target database. You will need to ensure this configuration constraint is resolved and set up prior to any sort of migration. ## What is Vstream and how does it work? VStream is a change notification service accessible via VTGate. The purpose of VStream is to provide equivalent information to the MySQL binary logs from the underlying MySQL shards. gRPC clients, including Vitess components like VTTablets, can subscribe to a VStream to receive change events from other shards. The VStream pulls events from one or more VStreamer instances on VTTablet instances, which in turn pulls events from the binary log of the underlying MySQL instance. This allows for efficient execution of functions such as VReplication where a subscriber can indirectly receive events from the binary logs of one or more MySQL instance shards, and then apply it to a target instance. --- title: Overview weight: 1 --- ## How do I migrate my data to Vitess? There are two main parts to migrating your data to Vitess: migrating the actual data and repointing the application. The answer here will focus primarily on the methods that can be used to migrate your data into Vitess. There are three different methods to migrate your data into Vitess. Choosing the appropriate option depends on several factors like: - The nature of the application accessing the MySQL database - The size of the MySQL database to be migrated - The load, especially the write load, on the MySQL database - Your tolerance for downtime during the migration of data - Whether you require the ability to reverse the migration if need be - The network level configuration of your components The three different methods are: - ‘Stop-the-world’ - VReplication from Vitess setup in 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.9864330887794495
  Content:
----------------------------------------
`keyspace.table` in your queries. However, once the setup exceeds the above complexity, VSchemas become a necessity. Vitess has a [working demo](https://github.com/vitessio/vitess/tree/main/examples/demo) of VSchemas. ## Sharding Model In Vitess, a `keyspace` is sharded by `keyspace ID` ranges. Each row is assigned a keyspace ID, which acts like a street address, and it determines the shard where the row lives. In some respect, one could say that the `keyspace ID` is the equivalent of a NoSQL sharding key. However, there are some differences: 1. The `keyspace ID` is a concept that is internal to Vitess. The application does not need to know anything about it. 2. There is no physical column that stores the actual `keyspace ID`. This value is computed as needed. This difference is significant enough that we do not refer to the keyspace ID as the sharding key. A [Primary Vindex](../vindexes/#the-primary-vindex) more closely resembles the NoSQL sharding key. Mapping to a `keyspace ID`, and then to a shard, gives us the flexibility to reshard the data with minimal disruption because the `keyspace ID` of each row remains unchanged through the process. ## Vindexes The Vschema contains the [Vindex](../vindexes) for any sharded tables. The Vindex tells Vitess where to find the shard that contains a particular row for a sharded table. Every VSchema must have at least one Vindex, called the [Primary Vindex](../vindexes/#the-primary-vindex), defined. The Primary Vindex is unique: given an input value, it produces a single keyspace ID, or value in the keyspace used to shard the table. The Primary Vindex is typically a functional Vindex: Vitess computes the keyspace ID as needed from a column in the sharded table. ## Sequences Auto-increment columns do not work very well for sharded tables. [Vitess sequences](../vitess-sequences) solve this problem. Sequence tables must be specified in the VSchema, and then tied to table columns. At the time of insert, if no value is specified for such a column, VTGate will generate a number for it using the sequence table. ## Reference tables Vitess allows you to create an unsharded table and deploy it into all shards of a sharded keyspace. The data in such a table is assumed to be identical for all shards. In this case, you can specify that the table is of type `reference`, and should not specify any vindex for it. Any joins of this table with an unsharded table will be treated as a local join. Typically, such a table has a canonical source in an unsharded keyspace, and the copies in the sharded keyspace are kept up-to-date through VReplication. ## Per-Keyspace VSchema The VSchema uses a flexible proto JSON format. Essentially, you can use `snake_case` or `camelCase` for the keys. The configuration of your VSchema reflects the desired sharding configuration for your database, including whether or not your tables are sharded and whether you want to implement a secondary Vindex. ### Commands You can use the following commands for maintaining the VSchema: * `GetVSchema <keyspace>` * `ApplyVSchema -- {--vschema=<vschema> || --vschema_file=<vschema file> || --sql=<sql> || --sql_file=<sql 
----------------------------------------

Document 4:
  Source: Unknown
  Score: 0.9812875390052795
  Content:
----------------------------------------
map to the same keyspace id `166B40B44ABA4BD6`. In other words, a unique vindex does not necessarily guarantee that two different values yield different keyspace ids. In fact, this is derived from the fact that there are two order rows for customer id `1`. Vindexes that do have a one-to-one correspondence between the input value and keyspace id , like `xxhash`, are known as reversible vindexes: Given a keyspace id, the input value can be back-computed. This property will be used in a later example. ### Backfill To Backfill the vindex on an existing table refer to [Backfill Vindexes](../backfill-vindexes) --- title: Unsharded Keyspace weight: 4 --- We are going to start with configuring the `product` table in the unsharded keyspace `product`. The schema file should be as follows: ```sql create table product(product_id bigint auto_increment, pname varchar(128), primary key(product_id)); ``` `product_id` is the primary key for product, and it is also configured to use MySQL’s `auto_increment` feature that allows you to automatically generate unique values for it. We also need to create a VSchema for the `product` keyspace and specify that `product` is a table in the keyspace: ```json { "sharded": false, "tables": { "product": {} } } ``` The json states that the keyspace is not sharded. The product table is specified in the “tables” section of the json. This is because there are other sections that we will introduce later. For unsharded keyspaces, no additional metadata is needed for regular tables. So, their entry is empty. Alternate VSchema DDL: ```sql alter vschema add table product.product; ``` {{< info >}} If `product` is the only keyspace in the cluster, a vschema is unnecessary. Vitess treats single keyspace clusters as a special case and optimistically forwards all queries to that keyspace even if there is no table metadata present in the vschema. But it is a best practice to provide a full vschema to avoid future complications. {{< /info >}} Bringing up the cluster will allow you to access the `product` table. You can now insert rows into the table: ```text $ mysql -h 127.0.0.1 -P 12348 [snip] mysql> insert into product(pname) values ('monitor'), ('keyboard'); Query OK, 2 rows affected (0.00 sec) mysql> select * from product; +------------+----------+ | product_id | pname | +------------+----------+ | 1 | monitor | | 2 | keyboard | +------------+----------+ 2 rows in set (0.00 sec) ``` The insert does not specify values for `product_id`, because we are relying on MySQL’s `auto_increment` feature to populate it. You will notice that we did not connect to the `product` database or issue a `use` statement to select it. This is the ‘unspecified’ mode supported by Vitess. As long as a table name can be uniquely identified from the vschemas, Vitess will automatically direct the query to the correct keyspace. You can also connect or specify keyspaces as if they were MySQL databases. The following constructs are valid: ```text mysql> select * from product.product; +------------+----------+ | product_id | pname | +------------+----------+ | 1 | monitor | | 2 | keyboard 
----------------------------------------

