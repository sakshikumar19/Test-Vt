DETAILED QUERY LOG - 2025-03-15 02:18:46
======================================================================

QUESTION: What should I do if my Vitess primary starts up in read-only mode?

ANSWER: ### Vitess Primary Starts Up Read-Only
If your Vitess primary starts up in read-only mode, it's likely due to the default `my.cnf` settings that tell MySQL to start up read-only. This is a safety measure to prevent accidental writes. 

#### Resolution Steps:
1. **Check if VTOrc is Running**: If VTOrc is running, it should automatically convert the primary to read-write mode.
2. **Manual Intervention**: If VTOrc is not running, you can use the [`SetReadWrite`](../../reference/programs/vtctl/tablets/#setreadwrite) command to manually set the primary to read-write mode.
3. **Consider Reparenting**: If the primary restarted due to an unexpected issue, it's recommended to reparent to a different replica using either [`EmergencyReparentShard`](../../reference/programs/vtctl/shards/#emergencyreparentshard) for unexpected issues or [`PlannedReparentShard`](../../reference/programs/vtctl/shards/#plannedreparentshard) for planned maintenance.

By following these steps, you can resolve the read-only mode issue with your Vitess primary and ensure your database is fully operational.

METRICS:
  - Documents Retrieved: 3
  - Top Document Score: 0.9986967444419861
  - Response Time: 25564.74 ms
  - Retrieval Time (est.): 17895.32 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9986967444419861
  Content:
----------------------------------------
cause. It could be network issues, or it could be a recent change in app behavior. Diagnosis 4: No particular transaction seems to be the culprit. Nothing seems to have changed in any of the requests. Look at system variables to see if there are hardware faults. Is the disk latency too high? Are there memory parity errors? If so, you may have to failover to a new machine. --- title: Primary starts up read-only description: Debug common issues with Vitess weight: 5 --- ## Primary starts up read-only To prevent accidentally accepting writes, our default my.cnf settings tell MySQL to always start up read-only. If the primary MySQL gets restarted, it will thus come back read-only until someone intervene to confirm that it should accept writes. If VTOrc is running, then it will take care of converting the primary to read-write mode. However, to fix manually, you can use the [`SetReadWrite`](../../reference/programs/vtctl/tablets/#setreadwrite) command to do that. Usually if something unexpected happens to the primary, it's better to reparent to a different replica with [`EmergencyReparentShard`](../../reference/programs/vtctl/shards/#emergencyreparentshard). If you need to do planned maintenance on the primary, it's best to first reparent to another replica with [`PlannedReparentShard`](../../reference/programs/vtctl/shards/#plannedreparentshard). --- title: Vitess sees the wrong tablet as primary description: Debug common issues with Vitess weight: 10 --- ## Vitess sees the wrong tablet as primary If you do a failover manually (not through Vitess), you'll need to tell Vitess which tablet corresponds to the new primary MySQL. Until then, writes will fail since they'll be routed to a read-only replica (the old primary). Use the [`TabletExternallyReparented`](../../reference/programs/vtctl/shards/#tabletexternallyreparented) command to tell Vitess the new primary tablet for a shard. Older versions of Vitess supported tools like [Orchestrator](https://github.com/github/orchestrator), which can be configured to call this automatically when a failover occurs. See our sample [orchestrator.conf.json](https://github.com/vitessio/vitess/blob/1129d69282bb738c94b8af661b984b6377a759f7/docker/orchestrator/orchestrator.conf.json#L131) for an example of 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.38066238164901733
  Content:
----------------------------------------
or `lookup_unique` vindexes. * `write_only` (false): if true, the vindex is kept updated, but a lookup will return all shards if the key is not found. This mode is used while the vindex is being populated and backfilled. * `no_verify` (false): if true, Vitess will not internally verify lookup results. This mode is a performance optimization that is unsafe to use unless the `from` columns in the `owner` table rows are never updated. * `read_lock` (exclusive): determines the type of locking read Vitess uses when querying the backing table. Valid options are `exclusive` (translates to a MySQL `FOR UPDATE` lock), `shared` (`LOCK IN SHARE MODE`) or `none`. Relaxing the default (`exclusive`) may improve performance, but is unsafe if concurrent queries can select and delete the same rows from the backing table. * `ignore_nulls` (false): if true, null values in input columns do not create entries in the lookup table. Otherwise, a null input results in an error. The `numeric_static_map` supports the following parameters: * `json_path`: Path to a file which must contain a JSON document that maps input numeric values to keyspace ids. * `json`: A string which must contain a JSON document that maps input numeric values to keyspace ids. * `fallback_type`: Name of a functional vindex, e.g. `xxhash`, to fallback to when looking up a key not present in the map. One of either `json_path` or `json` is required. The two are mutually exclusive. The `region_experimental` vindex is an experimental vindex that uses the first one or two bytes of the input value as prefix for keyspace id. The rest of the bits are hashed. This allows you to group users of the same region within the same group of shards. The vindex requires a `region_bytes` parameter that specifies if the prefix is one or two bytes. The 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.17872470617294312
  Content:
----------------------------------------
weight: 8 --- Let us assume that we want to bring up a single unsharded keyspace. The first step is to identify the number of replicas (including the primary) we would like to deploy. We should also make a decision about how to distribute them across the cells. Vitess requires you to assign a globally unique id (tablet UID) to every vttablet. This has to be an unsigned 32-bit integer. This is a legacy requirement derived from the fact that the MySQL server id (also an unsigned 32-bit integer) used to be the same as the tablet uid. This is not the case any more. In terms of mapping these components to machines, Vitess allows you to run multiple of these on the same machine. If this is the case, you will need to assign non-conflicting ports for these servers to listen on. VTTablet and MySQL are meant to be brought up as a pair within the same machine. By default, vttablet will connect to its MySQL over a unix socket. Let us look at the steps to bring up the first pair for an unsharded keyspace `commerce` in cell1 and a tablet uid of 100. ## Starting MySQL `mysqlctl` is a convenience wrapper that can bring up and initialize a fresh MySQL server, and isolate all associated files within directories that are tied to the unique UID. This makes it easy to bring up multiple MySQL instances on the same machine. The necessary arguments to a `mysqlctl` are the `tablet_uid` and `mysql_port`. Here is a sample invocation: ```sh mysqlctl \ --log_dir=${VTDATAROOT}/tmp \ --tablet_uid=100 \ --mysql_port=17100 \ init ``` ### my.cnf `mysqlctl` **will not** read configuration files from common locations such as `/etc/my.cnf` or `/etc/mysql/my.cnf`. Instead, it will create a separate `my.cnf` config file using builtin defaults. The source files 
----------------------------------------

