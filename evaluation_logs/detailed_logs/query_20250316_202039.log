DETAILED QUERY LOG - 2025-03-16 20:20:39
======================================================================

QUESTION: What is a scatter query in Vitess, and when is it used?

ANSWER: ### Scatter Query in Vitess
A scatter query in Vitess is a type of query that is routed to a sharded keyspace, but does not specify a vindex. 

### When is it Used
It is used when a query needs to be executed on all shards in a sharded keyspace, and the query cannot be routed using a vindex. This means that the query will be sent to all shards in the keyspace, rather than being targeted at a specific shard. 

Note that not all queries that are sent to multiple shards are considered scatter queries. Only those that are routed to a sharded keyspace without a vindex are classified as scatter queries.

METRICS:
  - Documents Retrieved: 4
  - Top Document Score: 0.9311490058898926
  - Response Time: 13403.73 ms

RETRIEVED DOCUMENTS:
Document 1:
  Source: Unknown
  Score: 0.9311490058898926
  Content:
----------------------------------------
leaf node will not have input from other operators, and pipe in any nodes they produce into their parent nodes. The parents nodes will then pipe in nodes to their parent nodes, all the way up to a root node. The root node produces the final results of the query and delivers the results to the user. ### Routing Operators A routing operator in an execution plan instructs Vitess which destination to send a piece of work to. Typically a routing operator will tell Vitess which keyspace to use when executing the piece of work, whether or not the keyspace is sharded, and, in the case of sharded keyspaces, which vindex to use. ### Scatter Queries A routing operator which specifies a sharded keyspace, but which does not specify a vindex, will "scatter" to all shards in a sharded keyspace. A "scatter" query contains one or more pieces of work routed to a sharded keyspace, but which cannot be routed using a vindex. Note that not all queries which are sent to multiple (or all) shards in a sharded keyspace are considered scatter queries. ### Observing Execution Plans Cached execution plans can be observed at the VTGate level by browsing the `/queryz` end point. Starting with Vitess 16, individual statement plans can also be observed with [`VExplain`](../../user-guides/sql/explain-format-vtexplain). **Related Vitess Documentation** * [VTGate](../vtgate) --- title: Keyspace ID --- The *keyspace ID* is the value that is used to decide on which shard a given row lives. [Range-based Sharding](../../reference/features/sharding/#key-ranges-and-partitions) refers to creating shards that each cover a particular range of keyspace IDs. Using this technique means you can split a given shard by replacing it with two or more new shards that combine to cover the original range of keyspace IDs, without having to move any records in other shards. The keyspace ID itself is computed using a function of some column in your data, such as the user ID. Vitess allows you to choose from a variety of functions ([vindexes](../../reference/features/vindexes/)) to perform this mapping. This allows you to choose the right one to achieve optimal distribution of the data across shards. --- title: Keyspace --- A *keyspace* is a logical database. If you're using [sharding](http://en.wikipedia.org/wiki/Shard_(database_architecture)), a keyspace maps to multiple MySQL databases; if you're not using sharding, a keyspace maps directly to a MySQL database name. In either case, a keyspace appears as a single database from the standpoint of the application. Reading data from a keyspace is just like reading from a MySQL database. However, depending on the consistency requirements of the read operation, Vitess might fetch the data from a primary database or from a replica. By routing each query to the appropriate database, Vitess allows your code to be structured as if it were reading from a single MySQL database. --- title: MoveTables --- MoveTables is a workflow based on VReplication. It enables you to relocate tables between keyspaces, and therefore physical MySQL instances, without downtime. ## Identifying Candidate Tables It is recommended to keep tables that need 
----------------------------------------

Document 2:
  Source: Unknown
  Score: 0.4087471663951874
  Content:
----------------------------------------
(OOM) situations. ## Scatter errors as warnings (`SCATTER_ERRORS_AS_WARNINGS`) Vitess will, by default, return only an error if any of the shards involved in a scatter query reports an error. This is important for strong correctness, however, in some cases it may be necessary or desirable to have Vitess return partial results from the available shards anyway. The application can then act accordingly based on the results. The `SCATTER_ERRORS_AS_WARNINGS` comment directive enables exactly this, by returning the partial results from the healthy shards in the scatter query, and returning the error(s) from the unhealthy shard(s) as warnings. The application can then potentially use the warning information to guide its subsequent action. ## Ignore max payload size (`IGNORE_MAX_PAYLOAD_SIZE`) By default, Vitess will try to handle queries of any size. It is possible to use the `vtgate` parameter `--max_payload_size` (default unlimited) to limit the size of an incoming query to a certain number of bytes. Queries larger than this limit will then be rejected by `vtgate`. The `IGNORE_MAX_PAYLOAD_SIZE` comment directive allows a Vitess-aware application to bypass this limit, essentially setting it to the default of unlimited for that query. ## Ignore max memory rows (`IGNORE_MAX_MEMORY_ROWS`) By default, `vtgate` will allow intermediate results for things like in-vtgate sorting and joining, up to a maximum of number of rows per query. This is to avoid using massive amounts of memory in `vtgate`. This limit is set using the `vtgate` parameter `--max_memory_rows`, which defaults to 300,000. Note that this limit is not a direct memory usage limit, since 300,000 very large rows could still be a huge amount of memory. The `IGNORE_MAX_MEMORY_ROWS` comment directive allows a Vitess-aware application to bypass this limit, essentially setting it to an unlimited number of rows for that query. Since this override can result in very large, and even potentially effectively unbounded, amounts of memory being used by `vtgate`, it should be used with extreme caution. ## Allow scatter (`ALLOW_SCATTER`) In Vitess, it is possible to use the `vtgate` parameter `--no_scatter` to prevent `vtgate` from issuing scatter queries. Thus only queries that do not scatter will be allowed. This comment directive is used to override that limitation, allowing application code to be customized to allow scatters for certain chosen use-cases, but not for the general case. ## Consolidator (`CONSOLIDATOR`) In `vttablet`, the consolidator is enabled with the `--enable_consolidator` and `--enable_consolidator_replicas` flags. Those settings may be overridden with this comment directive, allowing application code to opt into (or out of) consolidation for individual `SELECT` queries. This directive requires one of the following values: * `disabled` * `enabled` * `enabled_replicas` ### Planner (`PLANNER`) Overrides the default planner to the one specified by the directive. Example query: ```sql select /*vt+ PLANNER=gen4 */ * from user; ``` Valid values are the same as for the planner flag - `Gen4`, `Gen4Greedy` and `Gen4Left2Right`. ### Workload name (`WORKLOAD_NAME`) Specifies the client application workload name. This does not affect query execution, but can be used to instrument some `vttablet` metrics to include a label specifying the workload name. 
----------------------------------------

Document 3:
  Source: Unknown
  Score: 0.0729341208934784
  Content:
----------------------------------------
{ "Name": "customer", "Sharded": true }, "FieldQuery": "select c1, c2, c3, c4 from t1 where 1 != 1", "Query": "select c1, c2, c3, c4 from t1 where c1 = 1", "Table": "t1", "Values": [ "1" ], "Vindex": "t1_multicol" } 1 row in set (0.00 sec) ``` Note that the number of shards that these types of queries target. For queries that provide a subset of the subsharding vindex's columns in the `WHERE` clause the target is dependent on the structure (byte allocation) of the vindex and the number of shards in the keyspace. Next, let's show that providing no columns scatters (as expected): ``` mysql> vexplain plan select * from t1 \G *************************** 1. row *************************** JSON: { "OperatorType": "Route", "Variant": "Scatter", "Keyspace": { "Name": "customer", "Sharded": true }, "FieldQuery": "select c1, c2, c3, c4 from t1 where 1 != 1", "Query": "select c1, c2, c3, c4 from t1", "Table": "t1" } 1 row in set (0.01 sec) ``` Similarly, providing a column (or subset of columns) from the subsharding vindex that does not include the first column will lead to a scatter: ``` mysql> vexplain plan select * from t1 where c3=1 \G *************************** 1. row *************************** JSON: { "OperatorType": "Route", "Variant": "Scatter", "Keyspace": { "Name": "customer", "Sharded": true }, "FieldQuery": "select c1, c2, c3, c4 from t1 where 1 != 1", "Query": "select c1, c2, c3, c4 from t1 where c3 = 1", "Table": "t1" } 1 row in set (0.00 sec) mysql> vexplain plan select * from t1 where c2=1 and c3=1 \G *************************** 1. row *************************** JSON: { "OperatorType": "Route", "Variant": "Scatter", "Keyspace": { "Name": "customer", "Sharded": true }, "FieldQuery": "select c1, c2, c3, c4 from t1 where 1 != 1", "Query": "select c1, c2, c3, c4 from t1 where c2 = 1 and c3 = 1", "Table": "t1" } 1 row in set (0.00 sec) ``` --- title: Unique Lookup Vindexes weight: 8 --- Certain application features may require you to point-select orders by their id with a query like this: ```sql select * from corder where corder_id=1; ``` However, issuing this query to Vitess will cause it to scatter this query across all shards because there is no way to know which shard contains that order id. This would be inefficient if the QPS of this query or the number of shards is too high. Vitess supports the concept of lookup vindexes, also known as cross-shard indexes. You can instruct Vitess to create and manage a lookup vindex for the `corder_id` column. Such a vindex needs to maintain a mapping from `corder_id` to the `keyspace_id` of the row, which will be stored in a lookup table. This lookup table can be created in any keyspace, and it may or may not be sharded. In this particular case, we are going to create the table in the unsharded product keyspace even though the lookup vindex itself is going to be in the `customer` keyspace: ```sql create table corder_keyspace_idx(corder_id bigint, keyspace_id varbinary(10), primary key(corder_id)); ``` The 
----------------------------------------

Document 4:
  Source: Unknown
  Score: 0.05850740149617195
  Content:
----------------------------------------
a subset of the SQL language. | Vitess is not a simple key-value store. It supports complex query semantics such as where clauses, JOINS, aggregation functions, and more. | | NoSQL datastores do not usually support transactions. | Vitess supports transactions. | | NoSQL solutions have custom APIs, leading to custom architectures, applications, and tools. | Vitess adds very little variance to MySQL, a database that most people are already accustomed to working with. | | NoSQL solutions provide limited support for database indexes compared to MySQL. | Vitess allows you to use all of MySQL's indexing functionality to optimize query performance. | --- title: Overview description: High-level information about Vitess weight: 1 aliases: ['/docs/overview/scalingwithvitess/','/user-guide/introduction.html'] --- The Vitess overview documentation provides general information about Vitess that's less immediately practical than what you'll find in [Get Started](../get-started) section and the [User Guides](../user-guides). --- title: Reference description: Detailed information about specific Vitess functionality weight: 5 aliases: ['/docs/advanced/'] --- --- title: Metrics description: Metrics related to backup and restore functionality weight: 10 --- Backup and restore operations export several metrics using the expvars interface. These are available at the `/debug/vars` endpoint of Vtbackup's and VTTablet's http status pages. [More details can be found here](../../features/monitoring/#3-push-based-metrics-system). ## Backup metrics Metrics related to backup operations are available in both Vtbackup and VTTablet. #### BackupBytes, BackupCount, BackupDurationNanoseconds Depending on the Backup Engine and Backup Storage in-use, a backup may be a complex pipeline of operations, including but not limited to: * Reading files from disk. * Compressing files. * Uploading compress files to cloud object storage. These operations are counted and timed, and the number of bytes consumed or produced by each stage of the pipeline are counted as well. ## Restore metrics Metrics related to restore operations are available in both Vtbackup and VTTablet. #### RestoreBytes, RestoreCount, RestoreDurationNanoseconds Depending on the Backup Engine and Backup Storage in-use, a restore may be a complex pipeline of operations, including but not limited to: * Downloading compressed files from cloud object storage. * Decompressing files. * Writing decompressed files to disk. These operations are counted and timed, and the number of bytes consumed or produced by each stage of the pipeline are counted as well. #### RestoredBackupTime, RestorePosition _RestoredBackupTime_ captures the timestamp associated with the backup from which the current process was restored. _RestorePosition_ captures the GTID position associated with that backup. ## Vtbackup metrics Vtbackup exports some metrics which are not available elsewhere. #### DurationByPhaseSeconds Vtbackup fetches the last backup, restores it to an empty mysql installation, replicates recent changes into that installation, and then takes a backup of that installation. _DurationByPhaseSeconds_ exports timings for these individual phases. <hr style="border-top: 2px dashed brown"> ## Example **A snippet of vtbackup metrics after running it against the local example after creating the initial cluster** (Processed with `jq` for readability.) ``` { "BackupBytes": { "BackupEngine.Builtin.Source:Read": 4777, "BackupEngine.Builtin.Compressor:Write": 4616, "BackupEngine.Builtin.Destination:Write": 162, "BackupStorage.File.File:Write": 163 }, "BackupCount": { "-.-.Backup": 1, "BackupEngine.Builtin.Source:Open": 161, "BackupEngine.Builtin.Source:Close": 322, "BackupEngine.Builtin.Compressor:Close": 161, "BackupEngine.Builtin.Destination:Open": 161, "BackupEngine.Builtin.Destination:Close": 322 }, "BackupDurationNanoseconds": { "-.-.Backup": 
----------------------------------------

