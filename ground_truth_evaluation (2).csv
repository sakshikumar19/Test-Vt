question,answer,expected_chunks,retrieved_chunks,accuracy,found_chunks,total_expected,llm_judge
How can I debug elevated query latency on a Vitess primary?,"### Debugging Elevated Query Latency on a Vitess Primary

To debug elevated query latency on a Vitess primary, follow these steps:

#### Diagnosis 1: Increased QPS
1. **Inspect QPS graphs** to see if the queries per second have increased.
2. If QPS has gone up, **drill down on detailed QPS graphs** to identify which table or user is causing the increase.
3. **Analyze queries** on the identified table using `/debug/queryz`.
4. **Inform the engineer** about toxic queries and consider:
	* Stopping the job
	* Throttling the user
	* Blacklisting the query (as a last resort)

#### Diagnosis 2: Increased Latency without QPS Increase
1. **Inspect per-table latency graphs** to identify if a specific table is causing the issue.
2. If a table is identified, **identify the culprit query** and take necessary steps to optimize it.

#### Diagnosis 3: Across-the-Board Latency Increase
1. **Inspect transaction latency** to see if it has increased.
2. If transaction latency has increased, **check for tx pool full errors** and analyze the INFO logs to identify problematic transactions.
3. **Identify the root cause**, which could be network issues or recent changes in app behavior.

#### Diagnosis 4: No Obvious Culprit
1. **Check system variables** for hardware faults, such as disk issues.

### Additional Troubleshooting Steps
If the above steps are insufficient, you can:
1. **Inspect the `/queryz` page** for query stats and identify problematic queries.
2. **Use the real-time stream from `/debug/querylog`** to filter out unwanted tables and observe results.
3. **Resort to looking inside MySQL** if necessary, to find the root cause of the issue.","Inspect the graphs to see if QPS has gone up. If yes, drill down on the more detailed QPS graphs to see which table, or user caused the increase.
If a table is identified, look at /debug/queryz for queries on that table.
If QPS did not go up, only latency did, inspect the per-table latency graphs.","--- title: Elevated query latency on primary description: Debug common issues with Vitess weight: 1 --- ## Elevated query latency on primary Diagnosis 1: Inspect the graphs to see if QPS has gone up. If yes, drill down on the more detailed QPS graphs to see which table, or user caused the increase. If a table is identified, look at /debug/queryz for queries on that table. Action: Inform engineer about the toxic queries. If it’s a specific user, you can stop their job or throttle them to keep the load manageable. As a last resort, blacklist query to allow the rest of the system to stay healthy. Diagnosis 2: QPS did not go up, only latency did. Inspect the per-table latency graphs. If it’s a specific table, then it’s most likely a long-running low QPS query that’s skewing the numbers. Identify the culprit query and take necessary steps to get it optimized. Such queries usually do not cause outage. So, there may not be a need to take extreme measures. Diagnosis 3: Latency seems to be up across the board. Inspect transaction latency. If this has gone up, then something is causing MySQL to run too many concurrent transactions which causes slow-down. See if there are any tx pool full errors. If there is an increase, the INFO logs will dump info about all transactions. From there, you should be able to if a specific sequence of statements is causing the problem. Once that is identified, find out the root cause. It could be network issues, or it could be a recent change in app behavior. Diagnosis 4: No particular transaction seems to be the culprit. Nothing seems to have changed in any of the requests. Look at system variables to see if there are hardware faults. Is the disk 
specific query is causing the problem. There are two approaches: * Inspect the `/queryz` page and look at the stats for all queries of that table. It is very likely that the problematic ones have already risen to the top of the page and may be color-coded red. If not, talking a few snapshots of the page and comparing the stats should help identify the problematic query. * Real-time stream from `/debug/querylog`, filtering out unwanted tables and observing the results to identify the problematic query. Once the query is identified, the remedy depends on the situation. It could be a rewrite of the query to be more efficient, the creation of an additional index, or it could be the shutdown of an abusive batch process. The above guidelines have not required you to inspect MySQL. Over time, Vitess has evolved by improving its observability every time there was an incident. However, there may still be situations where the above approach is insufficient. If so, you will need to resort to looking inside MySQL to find out the root cause. The actual identification of the root cause may not be as straightforward as described above. Sometimes, an incident is caused by multiple factors. In such cases, using first principles of troubleshooting and understanding how the components communicate with each other may be the only way to get to the bottom of a problem. If you have exhausted all the recommendations given so far and still have not found the root cause, you may have to directly troubleshoot the problem at the MySQL level. ### Elevated Error Rates The analysis for elevated error rates for read queries follows steps similar to elevated latency. You should essentially use the same drill down approach to identify the root cause. ### Transaction timeouts Transaction timeouts 
the areas to focus on. The first step to troubleshooting is to have an established baseline. It is recommended that monitoring is set up for all the components as directed in the monitoring section. When there is an incident, the change in the graphs will likely help with identifying the root cause. ## Query Serving Most of the focus of Vitess monitoring centers around the cost of a query. Although not always true, we use the following rules of thumb to get a rough estimate: * In MySQL, the time taken by a query roughly translates to its actual cost. More often than not, the limiting factor is the number of disk IOPS. * In Vitess components, the payload contributes to the cost. The limiting factor is most often the CPU, followed by memory. * The cost of parsing and analyzing the input query has started to become significant. This is typically driven by the size and complexity of the query. Let us now go through some fire drills. ### Too many connections If you see an error that contains the string `Too many connections (errno 1040) (sqlstate 08004)`, then it means that the maximum number of connections allowed by MySQL has been exceeded. The remedy is to further increase the `max_connections` settings in MySQL. The other alternative is to reduce the pool sizes. As [recommended before](../vttablet-mysql/#starting-vttablet), the `max_connections` value should be set about double the number of connections allocated for pools. ### Elevated Query Latency This is one of the most common problems. It can show up as just an elevated latency with no external impact. Sometimes, the problem can be more acute where queries return errors due to timeouts. There can be multiple root causes. #### Approach 1: Validate resource usage and remove bottlenecks Check vtgate CPU usage: ",66.67%,2,3,Yes.
What should I do if my Vitess primary starts up in read-only mode?,"### Vitess Primary Starts Up Read-Only

If your Vitess primary starts up in read-only mode, you can manually fix this by using the [`SetReadWrite`](../../reference/programs/vtctl/tablets/#setreadwrite) command. 

However, it's recommended to investigate why the primary restarted and consider reparenting to a different replica using either:
- [`EmergencyReparentShard`](../../reference/programs/vtctl/shards/#emergencyreparentshard) for unexpected events
- [`PlannedReparentShard`](../../reference/programs/vtctl/shards/#plannedreparentshard) for planned maintenance

If VTOrc is running, it will automatically take care of converting the primary to read-write mode.","To prevent accidentally accepting writes, our default my.cnf settings tell MySQL to always start up read-only.
If VTOrc is running, then it will take care of converting the primary to read-write mode.
To fix manually, you can use the [`SetReadWrite`](../../reference/programs/vtctl/tablets/#setreadwrite) command.","cause. It could be network issues, or it could be a recent change in app behavior. Diagnosis 4: No particular transaction seems to be the culprit. Nothing seems to have changed in any of the requests. Look at system variables to see if there are hardware faults. Is the disk latency too high? Are there memory parity errors? If so, you may have to failover to a new machine. --- title: Primary starts up read-only description: Debug common issues with Vitess weight: 5 --- ## Primary starts up read-only To prevent accidentally accepting writes, our default my.cnf settings tell MySQL to always start up read-only. If the primary MySQL gets restarted, it will thus come back read-only until someone intervene to confirm that it should accept writes. If VTOrc is running, then it will take care of converting the primary to read-write mode. However, to fix manually, you can use the [`SetReadWrite`](../../reference/programs/vtctl/tablets/#setreadwrite) command to do that. Usually if something unexpected happens to the primary, it's better to reparent to a different replica with [`EmergencyReparentShard`](../../reference/programs/vtctl/shards/#emergencyreparentshard). If you need to do planned maintenance on the primary, it's best to first reparent to another replica with [`PlannedReparentShard`](../../reference/programs/vtctl/shards/#plannedreparentshard). --- title: Vitess sees the wrong tablet as primary description: Debug common issues with Vitess weight: 10 --- ## Vitess sees the wrong tablet as primary If you do a failover manually (not through Vitess), you'll need to tell Vitess which tablet corresponds to the new primary MySQL. Until then, writes will fail since they'll be routed to a read-only replica (the old primary). Use the [`TabletExternallyReparented`](../../reference/programs/vtctl/shards/#tabletexternallyreparented) command to tell Vitess the new primary tablet for a shard. Older versions of Vitess supported tools like [Orchestrator](https://github.com/github/orchestrator), which can be configured to call this automatically when a failover occurs. See our sample [orchestrator.conf.json](https://github.com/vitessio/vitess/blob/1129d69282bb738c94b8af661b984b6377a759f7/docker/orchestrator/orchestrator.conf.json#L131) for an example of 
or `lookup_unique` vindexes. * `write_only` (false): if true, the vindex is kept updated, but a lookup will return all shards if the key is not found. This mode is used while the vindex is being populated and backfilled. * `no_verify` (false): if true, Vitess will not internally verify lookup results. This mode is a performance optimization that is unsafe to use unless the `from` columns in the `owner` table rows are never updated. * `read_lock` (exclusive): determines the type of locking read Vitess uses when querying the backing table. Valid options are `exclusive` (translates to a MySQL `FOR UPDATE` lock), `shared` (`LOCK IN SHARE MODE`) or `none`. Relaxing the default (`exclusive`) may improve performance, but is unsafe if concurrent queries can select and delete the same rows from the backing table. * `ignore_nulls` (false): if true, null values in input columns do not create entries in the lookup table. Otherwise, a null input results in an error. The `numeric_static_map` supports the following parameters: * `json_path`: Path to a file which must contain a JSON document that maps input numeric values to keyspace ids. * `json`: A string which must contain a JSON document that maps input numeric values to keyspace ids. * `fallback_type`: Name of a functional vindex, e.g. `xxhash`, to fallback to when looking up a key not present in the map. One of either `json_path` or `json` is required. The two are mutually exclusive. The `region_experimental` vindex is an experimental vindex that uses the first one or two bytes of the input value as prefix for keyspace id. The rest of the bits are hashed. This allows you to group users of the same region within the same group of shards. The vindex requires a `region_bytes` parameter that specifies if the prefix is one or two bytes. The 
weight: 8 --- Let us assume that we want to bring up a single unsharded keyspace. The first step is to identify the number of replicas (including the primary) we would like to deploy. We should also make a decision about how to distribute them across the cells. Vitess requires you to assign a globally unique id (tablet UID) to every vttablet. This has to be an unsigned 32-bit integer. This is a legacy requirement derived from the fact that the MySQL server id (also an unsigned 32-bit integer) used to be the same as the tablet uid. This is not the case any more. In terms of mapping these components to machines, Vitess allows you to run multiple of these on the same machine. If this is the case, you will need to assign non-conflicting ports for these servers to listen on. VTTablet and MySQL are meant to be brought up as a pair within the same machine. By default, vttablet will connect to its MySQL over a unix socket. Let us look at the steps to bring up the first pair for an unsharded keyspace `commerce` in cell1 and a tablet uid of 100. ## Starting MySQL `mysqlctl` is a convenience wrapper that can bring up and initialize a fresh MySQL server, and isolate all associated files within directories that are tied to the unique UID. This makes it easy to bring up multiple MySQL instances on the same machine. The necessary arguments to a `mysqlctl` are the `tablet_uid` and `mysql_port`. Here is a sample invocation: ```sh mysqlctl \ --log_dir=${VTDATAROOT}/tmp \ --tablet_uid=100 \ --mysql_port=17100 \ init ``` ### my.cnf `mysqlctl` **will not** read configuration files from common locations such as `/etc/my.cnf` or `/etc/mysql/my.cnf`. Instead, it will create a separate `my.cnf` config file using builtin defaults. The source files ",66.67%,2,3,Yes.
How do I inform Vitess of a new primary tablet after a manual failover?,"### Informing Vitess of a New Primary Tablet After Manual Failover

To inform Vitess of a new primary tablet after a manual failover, you need to use the [`TabletExternallyReparented`](../../reference/programs/vtctl/shards/#tabletexternallyreparented) command. This command tells Vitess which tablet corresponds to the new primary MySQL, ensuring that writes are routed correctly and do not fail due to being sent to a read-only replica (the old primary). 

In older versions of Vitess, tools like [Orchestrator](https://github.com/github/orchestrator) can be configured to call this command automatically when a failover occurs. You can refer to the sample [orchestrator.conf.json](https://github.com/vitessio/vitess/blob/1129d69282bb738c94b8af661b984b6377a759f7/docker/orchestrator/orchestrator.conf.json#L131) for an example configuration.","If you do a failover manually (not through Vitess), you'll need to tell Vitess which tablet corresponds to the new primary MySQL.
Use the [`TabletExternallyReparented`](../../reference/programs/vtctl/shards/#tabletexternallyreparented) command to tell Vitess the new primary tablet for a shard.
Older versions of Vitess supported tools like [Orchestrator](https://github.com/github/orchestrator), which can be configured to call this automatically.","cause. It could be network issues, or it could be a recent change in app behavior. Diagnosis 4: No particular transaction seems to be the culprit. Nothing seems to have changed in any of the requests. Look at system variables to see if there are hardware faults. Is the disk latency too high? Are there memory parity errors? If so, you may have to failover to a new machine. --- title: Primary starts up read-only description: Debug common issues with Vitess weight: 5 --- ## Primary starts up read-only To prevent accidentally accepting writes, our default my.cnf settings tell MySQL to always start up read-only. If the primary MySQL gets restarted, it will thus come back read-only until someone intervene to confirm that it should accept writes. If VTOrc is running, then it will take care of converting the primary to read-write mode. However, to fix manually, you can use the [`SetReadWrite`](../../reference/programs/vtctl/tablets/#setreadwrite) command to do that. Usually if something unexpected happens to the primary, it's better to reparent to a different replica with [`EmergencyReparentShard`](../../reference/programs/vtctl/shards/#emergencyreparentshard). If you need to do planned maintenance on the primary, it's best to first reparent to another replica with [`PlannedReparentShard`](../../reference/programs/vtctl/shards/#plannedreparentshard). --- title: Vitess sees the wrong tablet as primary description: Debug common issues with Vitess weight: 10 --- ## Vitess sees the wrong tablet as primary If you do a failover manually (not through Vitess), you'll need to tell Vitess which tablet corresponds to the new primary MySQL. Until then, writes will fail since they'll be routed to a read-only replica (the old primary). Use the [`TabletExternallyReparented`](../../reference/programs/vtctl/shards/#tabletexternallyreparented) command to tell Vitess the new primary tablet for a shard. Older versions of Vitess supported tools like [Orchestrator](https://github.com/github/orchestrator), which can be configured to call this automatically when a failover occurs. See our sample [orchestrator.conf.json](https://github.com/vitessio/vitess/blob/1129d69282bb738c94b8af661b984b6377a759f7/docker/orchestrator/orchestrator.conf.json#L131) for an example of 
above, we introduced the schema tracker, which could be running on the VTTablets now. You can disable it in order to prevent that reporting. You will need to add `track_schema_versions` as false in the VTTablet. ## What are the steps to take after an unplanned failover? In order to avoid creating orphaned VTTablets you will need to follow the steps below: 1. Stop the VTTablets 2. Delete the old VTTablet records 3. Create the new keyspace 4. Restart the VTTablets that are pointed at the new keyspace 5. Use TabletExternallyReparented to inform Vitess of the current primary 6. Recursively delete the old keyspace ## Error: Could not open required defaults file: /path/to/my.cnf If you cannot start a cluster and see that error in the logs it most likely means that AppArmor is running on your server and is preventing Vitess processes from accessing the my.cnf file. The workaround is to uninstall AppArmor: ```sh sudo service apparmor stop sudo service apparmor teardown sudo update-rc.d -f apparmor remove ``` You may also need to reboot the machine after this. Many programs automatically install AppArmor, so you may need to uninstall again. ## Error: mysqld not found in any of /usr/bin/{sbin,bin,libexec} If you're all set up with Vitess but mysqld won't start, with an error like this: ```sh E0430 17:02:43.663441 5297 mysqlctl.go:254] failed start mysql: mysqld not found in any of /usr/bin/{sbin,bin,libexec} ``` You will need to perform the following steps: - Verify that mysqld is located in /usr/bin on all its hosts - Verify that PATH has been set and sourced in .bashrc If you have confirmed the above and are still getting the error referenced, it is likely that `VT_MYSQL_ROOT` has not been set correctly. On most systems `VT_MYSQL_ROOT` should be set to `/usr` because Vitess expects to find a bin 
(`vtgate`) whether Online DDL operations are at all possible through `VTGate`. Type: boolean. Default: `true` Example: `vtgate --enable_online_ddl=false` to disable access to Online DDL via `VTGate`. ## Auto resume after failure VReplication based migrations (`ddl_strategy=""vitess""`) are [failover agnostic](../recoverable-migrations/). They automatically resume after either planned promotion ([PlannedReparentShard](../../configuration-advanced/reparenting/#plannedreparentshard-planned-reparenting)), emergency promotion ([EmergencyReparentShard](../../configuration-advanced/reparenting/#emergencyreparentshard-emergency-reparenting)) or completely external reparenting. Once the new primary is in place and turns active, it auto-resumes the VReplication stream. The online DDL scheduler assumes ownership of the stream and follows it to completion. The new primary must be available within `10 minutes`, or else the migration is considered to be stale and is aborted. ## Auto retry after failure Vitess management can issue an automated retry (starting the migration afresh). - which `vttablet` initiated the migration - how many times a migration has been retried - whether a migration failed due to a `vttablet` failure (as is the case in a failover scenario) Vitess will auto-retry a failed migration when: - The migration failed due to a `vttablet` failure, and - it has not been retried (this is a temporary restriction) The migration will be transitioned into `queued` state, as if the user requested a `retry` operation. Note that this takes place on a per-shard basis. The primary use case is a primary failure and failover. The newly promoted tablet will be able to retry the migration that broke during the previous primary failure. To clarify, the migration will start anew, as at this time there is no mechanism to resume a broken migration. ## Throttling `vitess` utilizes the tablet throttler, which is a cooperative throttler service based on replication lag. The tablet throttler automatically detects topology `REPLICA` tablets and adapts to changes in the topology. See [Tablet throttler](../../../reference/features/tablet-throttler/). **NOTE** that at this time (and subject to change) the tablet throttler ",66.67%,2,3,Yes.
Where can I find troubleshooting resources in Vitess?,"### Troubleshooting Resources in Vitess

To find troubleshooting resources in Vitess, you can refer to the [Troubleshooting](../../configuration-advanced/reparenting) section. Additionally, the system provides various tools and commands to help with troubleshooting, such as:

* Checking the query serving path: `vtgate` -> `vttablet` -> `MySQL`
* Monitoring components: `vtgates`, `vttablets`, and `MySQL`
* Collecting information: logs, metrics, statistics, and configurations

You can also use commands like `TabletExternallyReparented` and `SetReadWrite` to resolve specific issues. For more information on these commands, you can refer to the [Vitess reference documentation](../../reference/programs/vtctl/tablets/#setreadwrite) and [Vitess reference documentation](../../reference/programs/vtctl/shards/#tabletexternallyreparented). 

It is recommended to set up monitoring for all components and collect as much information as possible when troubleshooting issues in your Vitess implementation.","If there is a problem in the system, one or many alerts would typically fire.
When an alert fires, you have the following sources of information to perform your investigation:
* Alert values
* Graphs
* Diagnostic URLs
* Log files","graceful shut down. {{< /info >}} For more information, please refer to the [Reparenting](../../configuration-advanced/reparenting) section. {{< info >}} A reparenting operation can fail in the middle. If so, it is possible for the system to be in a situation where two vttablets report themselves as primary. If this happens, the one with the newer timestamp wins. The vtgates will automatically treat the newer primary as authoritative. The system will eventually heal itself because the vttablets use a registration protocol via the global topo and the older tablet will demote itself to a replica when it notices that it is no longer the primary. {{< /info >}} --- title: Troubleshooting weight: 17 --- ## Understanding the Components The secret to troubleshooting a Vitess cluster well comes from knowing how all the components are wired together. Of these connections, the most important one is the query serving path: * The application sends a request to a vtgate. * The vtgate forwards that request to one or more vttablets. * The vttablets in turn send the request to MySQL. If there is any kind of problem with serving queries, these are the components to drill into. VTGates and vttablets connect to the global and cell-specific toposerver. They use these toposervers to broadcast their state as well as to discover configuration changes. Additionally, vtgates receive health information from the vttablets they are connected to, and use this information to direct traffic in real-time. If there is any kind of problem with configuration, these are the areas to focus on. The first step to troubleshooting is to have an established baseline. It is recommended that monitoring is set up for all the components as directed in the monitoring section. When there is an incident, the change in the graphs will likely help with identifying the 
can use this dump file to review these logs for any errors or issues. ## Collecting information for troubleshooting In order to troubleshoot issues occurring in your implementation of Vitess you will need to provide the community as much context as possible. When you reach out you should include, if possible, a summary/overview deployment document of what components are involved and how they interconnect, etc. Customers often maintain something like this for internal support purposes. Beyond the overview deployment document, we recommend that for the best experience, you collect as many of the items listed below as possible from production Vitess systems: - Logs (vtgate, vttablet, underlying MySQL) - Metrics (vtgate, vttablet, underlying MySQL) - Other statistics (MySQL processlist, MySQL InnoDB engine status, etc.) - Application DB pool configurations - Load balancer configurations (if in the MySQL connection path) - Historical load patterns --- title: Troubleshooting docs_nav_disable_expand: true weight: 4 ---
specific query is causing the problem. There are two approaches: * Inspect the `/queryz` page and look at the stats for all queries of that table. It is very likely that the problematic ones have already risen to the top of the page and may be color-coded red. If not, talking a few snapshots of the page and comparing the stats should help identify the problematic query. * Real-time stream from `/debug/querylog`, filtering out unwanted tables and observing the results to identify the problematic query. Once the query is identified, the remedy depends on the situation. It could be a rewrite of the query to be more efficient, the creation of an additional index, or it could be the shutdown of an abusive batch process. The above guidelines have not required you to inspect MySQL. Over time, Vitess has evolved by improving its observability every time there was an incident. However, there may still be situations where the above approach is insufficient. If so, you will need to resort to looking inside MySQL to find out the root cause. The actual identification of the root cause may not be as straightforward as described above. Sometimes, an incident is caused by multiple factors. In such cases, using first principles of troubleshooting and understanding how the components communicate with each other may be the only way to get to the bottom of a problem. If you have exhausted all the recommendations given so far and still have not found the root cause, you may have to directly troubleshoot the problem at the MySQL level. ### Elevated Error Rates The analysis for elevated error rates for read queries follows steps similar to elevated latency. You should essentially use the same drill down approach to identify the root cause. ### Transaction timeouts Transaction timeouts ",0.00%,0,3,Yes.
How do I check the version of my Vitess build?,"### Checking the Version of Your Vitess Build

To check the version of your Vitess build, you can use the following command:
```sh
$ git clone https://github.com/vitessio/vitess.git
$ cd vitess
$ make build
$ cd bin
$ ./vtctl version
```
However, since the provided context does not explicitly mention a `version` command for Vitess, you can check the version of the tools you have installed, such as `go`, `mysql`, `mysqld`, `etcd`, `node`, and `npm`, using the following commands:
```sh
$ go version
$ mysql --version
$ mysqld --version
$ etcd --version
$ node --version
$ npm --version
```
If you need to verify the Vitess version, you may want to check the `git` repository or the build artifacts for version information. 

I don't have enough information to provide a direct command to check the Vitess version. More information about the Vitess build process or the `vtctl` command might help.","Find version of Vitess build
``` select @@version; ```","shutdown of MySQL: ```sh $ brew services stop mysql ``` ### Install Node 18.16.0+ (required to run VTAdmin) ```bash brew install nvm nvm install --lts 18.16.0 nvm use 18.16.0 ``` See the [vtadmin README](https://github.com/vitessio/vitess/blob/main/web/vtadmin/README.md) for more details. ## PATH Settings With the tools you’ve just installed via brew, you will next update your PATH variable so your shell knows where to find the binaries: ```sh echo ""export PATH=${PATH}:/opt/homebrew/opt/mysql-client/bin:/opt/homebrew/opt/mysql/bin:${HOME}/go/bin:/opt/homebrew/bin"" >> ~/.zshrc source ~/.zshrc ``` If you’re using bash for your shell you’ll have to update the paths in `.bash_profile` or `.bashrc` instead. Mac does not read `.bashrc` by default: ```sh echo ""export PATH=${PATH}:/opt/homebrew/opt/mysql-client/bin:/opt/homebrew/opt/mysql/bin:${HOME}/go/bin:/opt/homebrew/bin"" >> ~/.bash_profile source ~/.bash_profile ``` ## System Check Before going further, you should check to confirm your shell has access to `go`, `mysql`, and `mysqld`. If versions are not returned when you run the following commands you should check that the programs are installed and the path is correct for your shell: ```sh $ mysqld --version $ mysql --version $ go version $ etcd --version $ node --version $ npm --version ``` ## Install Vitess With everything now in place you can clone and build Vitess. ```sh $ git clone https://github.com/vitessio/vitess.git $ cd vitess $ make build ``` It will take some time for Vitess to build. Once it completes you should see a bin folder which will hold the Vitess binaries. You will need to add this folder to your `PATH` variable as well: ```sh $ cd bin $ echo ""$(printf 'export PATH=""${PATH}:'; echo ""$(pwd)\"""")"" >> ~/.zshrc $ source ~/.zshrc ``` If you are using bash this will need to be your `.bash_profile` or `.bashrc` file instead: ```sh $ cd bin $ echo ""$(printf 'export PATH=""${PATH}:'; echo ""$(pwd)\"""")"" >> ~/.bash_profile $ source ~/.bash_profile ``` You are now ready to start your first cluster! Open a new terminal 
routed to a read-only replica (the old primary). Use the [`TabletExternallyReparented`](../../reference/programs/vtctl/shards/#tabletexternallyreparented) command to tell Vitess the new primary tablet for a shard. Older versions of Vitess supported tools like [Orchestrator](https://github.com/github/orchestrator), which can be configured to call this automatically when a failover occurs. See our sample [orchestrator.conf.json](https://github.com/vitessio/vitess/blob/1129d69282bb738c94b8af661b984b6377a759f7/docker/orchestrator/orchestrator.conf.json#L131) for an example of this. --- title: Troubleshoot aliases: ['/docs/launching/troubleshooting/'] description: Debug common issues with Vitess weight: 2600 --- If there is a problem in the system, one or many alerts would typically fire. If a problem was found through means other than an alert, then the alert system needs to be iterated upon. When an alert fires, you have the following sources of information to perform your investigation: * Alert values * Graphs * Diagnostic URLs * Log files ### Find version of Vitess build ``` select @@version; ```
``` ## Install Node ```sh curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash ``` Ensure the following is in your bashrc/zshrc or similar. `nvm` automatically attempts to add them: ```bash export NVM_DIR=""$HOME/.nvm"" [ -s ""$NVM_DIR/nvm.sh"" ] && \. ""$NVM_DIR/nvm.sh"" # This loads nvm [ -s ""$NVM_DIR/bash_completion"" ] && \. ""$NVM_DIR/bash_completion"" ``` Finally, install [node](https://nodejs.org/): ```sh nvm install 18 nvm use 18 ``` See the [vtadmin README](https://github.com/vitessio/vitess/blob/main/web/vtadmin/README.md) for more details. ## Disable AppArmor or SELinux AppArmor/SELinux will not allow Vitess to launch MySQL in any data directory by default. You will need to disable it: __AppArmor__: ```sh # Debian and Ubuntu sudo ln -s /etc/apparmor.d/usr.sbin.mysqld /etc/apparmor.d/disable/ sudo apparmor_parser -R /etc/apparmor.d/usr.sbin.mysqld # The following command should return an empty result: sudo aa-status | grep mysqld ``` __SELinux__: ```sh # CentOS sudo setenforce 0 ``` ## Install Vitess Download the [latest binary release](https://github.com/vitessio/vitess/releases) for Vitess on Linux: **Notes:** * Ubuntu is the only fully supported OS, for another OS please [build Vitess by yourself](/docs/contributing) or use the Docker images. ```sh version=""{{< latest_release >}}"" url=""$(curl -s https://api.github.com/repos/vitessio/vitess/releases | jq --arg version ""${version}"" -r '[.[] | select(.tag_name | contains($version))] | sort_by(.created_at) | reverse | .[0:1] | .[] | .assets[] | select(.content_type | contains(""application/gzip"")) | .browser_download_url')"" file=""${url##*/}"" curl -LO ""${url}"" tar -xzf ${file} cd ${file/.tar.gz/} sudo mkdir -p /usr/local/vitess sudo cp -r * /usr/local/vitess/ ``` Make sure to add `/usr/local/vitess/bin` to the `PATH` environment variable. You can do this by adding the following to your `$HOME/.bashrc` file: ```sh export PATH=/usr/local/vitess/bin:${PATH} ``` You are now ready to start your first cluster! Open a new terminal window to ensure your `.bashrc` file changes take effect. ## Start a Single Keyspace Cluster Start by copying the local examples included with Vitess to your preferred location. For our first example we will deploy a [single unsharded keyspace](../../concepts/keyspace). The file `101_initial_cluster.sh` is for example ",100.00%,2,2,No.
How do I check the version of my Vitess build?,"### Checking the Version of Your Vitess Build

To check the version of your Vitess build, you can use the following command:
```sh
$ git clone https://github.com/vitessio/vitess.git
$ cd vitess
$ make build
$ cd bin
$ ./vtctl version
```
However, since the provided context does not explicitly mention a `version` command for Vitess, you can check the version of the tools you have installed, such as `go`, `mysql`, `mysqld`, `etcd`, `node`, and `npm`, using the following commands:
```sh
$ go version
$ mysql --version
$ mysqld --version
$ etcd --version
$ node --version
$ npm --version
```
If you need to verify the Vitess version, you may want to check the `git` repository or the build artifacts for version information. 

I don't have enough information to provide a direct command to check the Vitess version. More information about the Vitess build process or the `vtctl` command might help.","Find version of Vitess build
``` select @@version; ```","shutdown of MySQL: ```sh $ brew services stop mysql ``` ### Install Node 18.16.0+ (required to run VTAdmin) ```bash brew install nvm nvm install --lts 18.16.0 nvm use 18.16.0 ``` See the [vtadmin README](https://github.com/vitessio/vitess/blob/main/web/vtadmin/README.md) for more details. ## PATH Settings With the tools you’ve just installed via brew, you will next update your PATH variable so your shell knows where to find the binaries: ```sh echo ""export PATH=${PATH}:/opt/homebrew/opt/mysql-client/bin:/opt/homebrew/opt/mysql/bin:${HOME}/go/bin:/opt/homebrew/bin"" >> ~/.zshrc source ~/.zshrc ``` If you’re using bash for your shell you’ll have to update the paths in `.bash_profile` or `.bashrc` instead. Mac does not read `.bashrc` by default: ```sh echo ""export PATH=${PATH}:/opt/homebrew/opt/mysql-client/bin:/opt/homebrew/opt/mysql/bin:${HOME}/go/bin:/opt/homebrew/bin"" >> ~/.bash_profile source ~/.bash_profile ``` ## System Check Before going further, you should check to confirm your shell has access to `go`, `mysql`, and `mysqld`. If versions are not returned when you run the following commands you should check that the programs are installed and the path is correct for your shell: ```sh $ mysqld --version $ mysql --version $ go version $ etcd --version $ node --version $ npm --version ``` ## Install Vitess With everything now in place you can clone and build Vitess. ```sh $ git clone https://github.com/vitessio/vitess.git $ cd vitess $ make build ``` It will take some time for Vitess to build. Once it completes you should see a bin folder which will hold the Vitess binaries. You will need to add this folder to your `PATH` variable as well: ```sh $ cd bin $ echo ""$(printf 'export PATH=""${PATH}:'; echo ""$(pwd)\"""")"" >> ~/.zshrc $ source ~/.zshrc ``` If you are using bash this will need to be your `.bash_profile` or `.bashrc` file instead: ```sh $ cd bin $ echo ""$(printf 'export PATH=""${PATH}:'; echo ""$(pwd)\"""")"" >> ~/.bash_profile $ source ~/.bash_profile ``` You are now ready to start your first cluster! Open a new terminal 
routed to a read-only replica (the old primary). Use the [`TabletExternallyReparented`](../../reference/programs/vtctl/shards/#tabletexternallyreparented) command to tell Vitess the new primary tablet for a shard. Older versions of Vitess supported tools like [Orchestrator](https://github.com/github/orchestrator), which can be configured to call this automatically when a failover occurs. See our sample [orchestrator.conf.json](https://github.com/vitessio/vitess/blob/1129d69282bb738c94b8af661b984b6377a759f7/docker/orchestrator/orchestrator.conf.json#L131) for an example of this. --- title: Troubleshoot aliases: ['/docs/launching/troubleshooting/'] description: Debug common issues with Vitess weight: 2600 --- If there is a problem in the system, one or many alerts would typically fire. If a problem was found through means other than an alert, then the alert system needs to be iterated upon. When an alert fires, you have the following sources of information to perform your investigation: * Alert values * Graphs * Diagnostic URLs * Log files ### Find version of Vitess build ``` select @@version; ```
``` ## Install Node ```sh curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash ``` Ensure the following is in your bashrc/zshrc or similar. `nvm` automatically attempts to add them: ```bash export NVM_DIR=""$HOME/.nvm"" [ -s ""$NVM_DIR/nvm.sh"" ] && \. ""$NVM_DIR/nvm.sh"" # This loads nvm [ -s ""$NVM_DIR/bash_completion"" ] && \. ""$NVM_DIR/bash_completion"" ``` Finally, install [node](https://nodejs.org/): ```sh nvm install 18 nvm use 18 ``` See the [vtadmin README](https://github.com/vitessio/vitess/blob/main/web/vtadmin/README.md) for more details. ## Disable AppArmor or SELinux AppArmor/SELinux will not allow Vitess to launch MySQL in any data directory by default. You will need to disable it: __AppArmor__: ```sh # Debian and Ubuntu sudo ln -s /etc/apparmor.d/usr.sbin.mysqld /etc/apparmor.d/disable/ sudo apparmor_parser -R /etc/apparmor.d/usr.sbin.mysqld # The following command should return an empty result: sudo aa-status | grep mysqld ``` __SELinux__: ```sh # CentOS sudo setenforce 0 ``` ## Install Vitess Download the [latest binary release](https://github.com/vitessio/vitess/releases) for Vitess on Linux: **Notes:** * Ubuntu is the only fully supported OS, for another OS please [build Vitess by yourself](/docs/contributing) or use the Docker images. ```sh version=""{{< latest_release >}}"" url=""$(curl -s https://api.github.com/repos/vitessio/vitess/releases | jq --arg version ""${version}"" -r '[.[] | select(.tag_name | contains($version))] | sort_by(.created_at) | reverse | .[0:1] | .[] | .assets[] | select(.content_type | contains(""application/gzip"")) | .browser_download_url')"" file=""${url##*/}"" curl -LO ""${url}"" tar -xzf ${file} cd ${file/.tar.gz/} sudo mkdir -p /usr/local/vitess sudo cp -r * /usr/local/vitess/ ``` Make sure to add `/usr/local/vitess/bin` to the `PATH` environment variable. You can do this by adding the following to your `$HOME/.bashrc` file: ```sh export PATH=/usr/local/vitess/bin:${PATH} ``` You are now ready to start your first cluster! Open a new terminal window to ensure your `.bashrc` file changes take effect. ## Start a Single Keyspace Cluster Start by copying the local examples included with Vitess to your preferred location. For our first example we will deploy a [single unsharded keyspace](../../concepts/keyspace). The file `101_initial_cluster.sh` is for example ",100.00%,2,2,No.
