test_cases:
  - question: What is an execution plan in Vitess, and how does it optimize query execution?
    expected_chunks:
      - "Vitess parses queries at both the VTGate and VTTablet layer in order to evaluate the best method to execute a query. This evaluation is known as query planning, and results in a _query execution plan_. The Execution Plan is dependent on both the query and the associated [VSchema](../vschema). One of the underlying goals of Vitess' planning strategy is to push down as much work as possible to the underlying MySQL instances. When this is not possible, Vitess will use a plan that collects input from multiple sources and merges the results to produce the correct query result."

  - question: What is a scatter query in Vitess, and when is it used?
    expected_chunks:
      - 'A routing operator which specifies a sharded keyspace, but which does not specify a vindex, will "scatter" to all shards in a sharded keyspace. A "scatter" query contains one or more pieces of work routed to a sharded keyspace, but which cannot be routed using a vindex. Note that not all queries which are sent to multiple (or all) shards in a sharded keyspace are considered scatter queries.'

  - question: What is the purpose of a keyspace in Vitess, and how does it differ between sharded and unsharded setups?
    expected_chunks:
      - "A *keyspace* is a logical database. If you're using [sharding](http://en.wikipedia.org/wiki/Shard_(database_architecture)), a keyspace maps to multiple MySQL databases; if you're not using sharding, a keyspace maps directly to a MySQL database name. In either case, a keyspace appears as a single database from the standpoint of the application."

  - question: What is connection pooling in Vitess, and why is it important for performance?
    expected_chunks:
      - "Connection pooling is important for the performance of Vitess, so this should not be the normal way to run applications on Vitess. Just make sure that the global variable is set to the same value the application will set it to, and Vitess can use connection pooling. Vitess now has support for connection-pooling even for these settings that originally required reserved connections."

  - question: What is the purpose of VStream in Vitess, and how does it facilitate change data capture (CDC)?
    expected_chunks:
      - "VStream is a change notification service accessible via VTGate. The purpose of VStream is to provide equivalent information to the MySQL binary logs from the underlying MySQL shards. gRPC clients, including Vitess components like VTTablets, can subscribe to a VStream to receive change events from other shards. The VStream pulls events from one or more VStreamer instances on VTTablet instances, which in turn pulls events from the binary log of the underlying MySQL instance. This allows for efficient execution of functions such as VReplication where a subscriber can indirectly receive events from the binary logs of one or more MySQL instance shards, and then apply it to a target instance."

  - question: How does VTGate route queries to the appropriate VTTablet servers in Vitess?
    expected_chunks:
      - "VTGate is a lightweight proxy server that routes traffic to the correct [VTTablet](../tablet) servers and returns consolidated results back to the client. It speaks both the MySQL Protocol and the Vitess gRPC protocol. Thus, your applications can connect to VTGate as if it is a MySQL Server. When routing queries to the appropriate VTTablet servers, VTGate considers the sharding scheme, required latency and the availability of tables and their underlying MySQL instances."

  - question: How does Vitess manage user-defined variables and ensure session state consistency?
    expected_chunks:
      - "User defined variables are kept in the session state when working with MySQL. You can assign values to them using SET: ```sql SET @my_user_variable = 'foobar' ``` And later there can be queries using for example SELECT: ```sql > SELECT @my_user_variable; +-------------------+ | @my_user_variable | +-------------------+ | foobar | +-------------------+ ``` If you execute these queries against a VTGate, the first `SET` query is not sent to MySQL. Instead, it is evaluated in the VTGate, and VTGate will keep this state for you. The second query is also not sent down. Trivial queries such as this one are actually fully executed on VTGate. If we try a more complicated query that requires data from MySQL, VTGate will rewrite the query before sending it down. If we were to write something like: ```sql WHERE col = @my_user_variable ``` What MySQL will see is: ```sql WHERE col = 'foobar' ``` This way, no session state is needed to evaluate the query in MySQL."

  - question: What are the five ways Vitess handles MySQL system variables, and can you provide examples of each?
    expected_chunks:
      - "Vitess handles system variables in one of five different ways: * *No op*. For some settings, Vitess will just silently ignore the setting. This is for system variables that don't make much sense in a sharded setting, and don't change the behaviour of MySQL in an interesting way. * *Check and fail if not already set*. These are settings that should not change, but Vitess will allow SET statements that try to set the variable to whatever it already is. * *Not supported*. For these settings, attempting to change them will always result in an error. * *Vitess aware*. These are settings that change Vitess' behaviour, and are not sent down to MySQL * *Reserved connection*. For some settings, it makes sense to allow them to be set, but it makes using a shared connection for this user much harder. By default, Vitess will first apply these system variables that are set, and then keep the connection dedicated for this user."

  - question: Explain the role of the VTGate component in Vitess architecture. How does it help in query routing and load balancing?
    expected_chunks:
      - "VTGate is a lightweight proxy server that sits between your application and your shards, which contain your data. VTGates are essentially stateless and in many cases, you can scale with query load by adding more VTGate instances. Some of the main functions performed by VTGate are as follows: * Keeps track of the Vitess cluster state, and route traffic accordingly. * Parses SQL queries fully, and combines that understanding with Vitess VSchema to direct queries to the appropriate VTTablet (or set of VTTablets) and returns consolidated results back to the client. * Supports both the MySQL Protocol and the gRPC protocol. Thus, your applications can connect to VTGate as if it is a MySQL Server. * Is aware of failovers in underlying shards, and performs buffering of queries to reduce application impact."

  - question: What are the key differences between Vitess and traditional MySQL in terms of scalability and transaction management?
    expected_chunks:
      - "Vitess improves a vanilla MySQL implementation in several ways: | Vanilla MySQL | Vitess | |:--|:--| | Every MySQL connection has a memory overhead that ranges between 256KB and almost 3MB, depending on which MySQL release you're using. As your user base grows, you need to add RAM to support additional connections, but the RAM does not contribute to faster queries. In addition, there is a significant CPU cost associated with obtaining the connections. | Vitess creates very lightweight connections. Vitess' connection pooling feature uses Go's concurrency support to map these lightweight connections to a small pool of MySQL connections. As such, Vitess can easily handle thousands of connections. | | Poorly written queries, such as those that don't set a LIMIT, can negatively impact the performance of the database. | Vitess rewrites queries to add limits and avoid non-deterministic updates. | | MySQL has limited support for sharding. | Vitess provides built-in sharding support, allowing you to scale your database horizontally. | | MySQL has limited support for high availability and failover. | Vitess provides built-in support for high availability and failover, ensuring that your database remains available even in the event of a failure. |"

  - question: How does Vitess handle distributed transactions, and what are the trade-offs of using Two-Phase Commit (TwoPC)?
    expected_chunks:
      - "Vitess also supports (assuming the vtgate and vttablets have been configured appropriately) a two-phase commit option for multi-shard writes. This is enabled by using the non-default setting for `transaction_mode` of **TWOPC**. In this mode, Vitess can guarantee atomicity for cross-shard writes; but still does not guarantee isolation; i.e. other clients can still see partial commits across shards. It should be emphasized that if you need to use **TWOPC** extensively in your application, you may be using Vitess incorrectly; the vast majority of Vitess users do not use it at all. See our [TWOPC page](../../../reference/features/distributed-transaction/) for more details on how to configure **TWOPC**. In TWOPC mode, Vitess uses the `_vt` sidecar database to record metadata related to each transactions across multiple tables. As a result, any multi-shard write in **TWOPC** mode is likely to be an order of a magnitude slower than in **MULTI** mode."

  - question: What is the significance of semi-sync replication in Vitess, and how does it enhance durability and high availability?
    expected_chunks:
      - "Vitess strongly recommends the use of Semi-synchronous replication for High Availability. The characteristics of semi-sync are replication governed by the [Durability Policy](../../../user-guides/configuration-basic/durability_policy) configured for the keyspace. Some characteristics are shared by all the policies - * Vitess configures the semi-sync timeout to essentially an unlimited number so that it will never fallback to asyncronous replication. This is important to prevent split brain (or alternate futures) in case of a network partition. If we can verify all replicas have stopped replicating, we know the old primary is not accepting writes, even if we are unable to contact the old primary itself. * All pre-configured durability policies do not allow tablets of type rdonly to send semi-sync ACKs. This is intentional because rdonly tablets are not eligible to be promoted to primary, so Vitess avoids the case where a rdonly tablet is the single best candidate for election at the time of primary failure. Having semi-sync enabled, gives you the property that, in case of primary failure, there is at least one other replica that has every transaction that was ever reported to clients as having completed."

  - question: How does Vitess handle backup and restore operations, and what are the key considerations for ensuring data integrity during these processes?
    expected_chunks:
      - "Vitess supports full backups as well as incremental backups, and their respective counterparts full restores and point-in-time restores. * A full backup contains the entire data in the database. The backup represents a consistent state of the data, i.e. it is a snapshot of the data at some point in time. * An incremental backup contains a changelog, or a transition of data from one state to another. Vitess implements incremental backups by making a copy of MySQL binary logs. Generally speaking and on most workloads, the cost of a full backup is higher, and the cost of incremental backups is lower. The time it takes to create a full backup is significant, and it is therefore impractical to take full backups in very small intervals. Moreover, a full backup consumes the disk space needed for the entire dataset. Incremental backups, on the other hand, are quick to run, and have very little impact, if any, to the running servers. They only contain the changes in between two points in time, and on most workloads are more compact. Full and incremental backups are expected to be interleaved. For example: one would create a full backup once per day, and incremental backups once per hour. Full backups are simply states of the database. Incremental backups, however, need to start with some point and end with some point. The common practice is for an incremental backup to continue from the point of the last good backup, which can be a full or incremental backup. An inremental backup in Vitess ends at the point in time of execution. The identity of the tablet on which a full backup or an incremental backup is taken is immaterial. It is possible to take a full backup on one tablet and incremental backups on another. It is possible to take full backups on two different tablets. It is also possible to take incremental backups, independently, on two different tablets, even though the contents of those incremental backups overlaps. Vitess uses MySQL GTID sets to determine positioning and prune duplicates."
